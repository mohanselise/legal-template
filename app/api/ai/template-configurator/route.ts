import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { createCompletionWithTracking } from "@/lib/openrouter";
import { getSessionId } from "@/lib/analytics/session";
import { prisma } from "@/lib/db";

// Default model if not configured in settings
const DEFAULT_CONFIGURATOR_MODEL = "anthropic/claude-sonnet-4";

// ============================================================================
// DYNAMIC SCHEMA REFERENCE - This is the complete form builder capability
// ============================================================================

const FORM_SCHEMA_REFERENCE = `
## COMPLETE FORM BUILDER SCHEMA

You have access to a powerful form builder system. Here's everything you can create:

### SCREEN TYPES

1. **standard** (default): Regular form screen with custom fields
   - Most common type for collecting user input
   - Supports all field types and AI enrichment
   - Use for: Party info, contract terms, compensation details, etc.

2. **signatory**: Special screen for collecting signatory/party information
   - Pre-built UI for managing multiple signatories
   - Supports: name, email, title, phone, company, address
   - Modes: "deterministic" (fixed slots) or "dynamic" (user adds/removes)
   - Use for: Collecting parties who will sign the document

3. **dynamic**: AI-generated screen with fields created on-the-fly
   - Fields are generated by AI based on context from previous screens
   - Useful for conditional/context-dependent data collection
   - Requires: dynamicPrompt (AI instructions), dynamicMaxFields (limit)

### FIELD TYPES (for standard screens)

| Type | Description | Use Case |
|------|-------------|----------|
| text | Single-line text input | Names, titles, addresses, general text |
| email | Email with validation | Contact emails, notification addresses |
| date | Date picker | Start dates, end dates, deadlines |
| number | Numeric input | Salaries, amounts, quantities, percentages |
| checkbox | Boolean yes/no | Agreements, optional clauses, confirmations |
| select | Dropdown with options | Fixed choices (countries, currencies, types) |

### FIELD PROPERTIES

Required:
- name: camelCase identifier (unique within screen)
- label: Human-readable display label
- type: One of the field types above
- required: Boolean - whether field must be filled

Optional:
- placeholder: Hint text shown in empty input
- helpText: Explanation text below field (great for legal context)
- options: String array (REQUIRED for select type)
- aiSuggestionEnabled: Boolean - enable AI auto-fill from enrichment context
- aiSuggestionKey: String - key from previous screen's AI enrichment output

### SCREEN PROPERTIES

Required:
- title: Screen heading
- fields: Array of field objects (for standard type)

Optional:
- description: Helper text explaining the screen's purpose
- type: "standard" | "signatory" | "dynamic" (defaults to standard)
- aiEnrichment: Object with prompt and outputSchema (for AI context generation)

For signatory screens:
- signatoryConfig: { mode, partyTypes, minSignatories, maxSignatories, collectFields, predefinedSignatories }

For dynamic screens:
- dynamicPrompt: AI instructions to generate fields
- dynamicMaxFields: Maximum fields to generate (default: 5)

### AI ENRICHMENT SYSTEM

The AI Enrichment system creates intelligent form auto-fill:

1. **Screen Enrichment Prompt**: Runs after screen completion
   - Reference fields with {{fieldName}} syntax
   - Analyzes user inputs to infer additional context

2. **Output Schema**: Defines context variables generated
   - JSON Schema format with properties and types
   - These become available for later screens' aiSuggestionKey

3. **Field AI Suggestions**: Auto-populate from enrichment
   - Set aiSuggestionEnabled: true
   - Set aiSuggestionKey: "propertyNameFromSchema"
   - User sees suggested value they can accept or modify

### SIGNATORY SCREEN CONFIGURATION

For type: "signatory", use signatoryConfig:
{
  "mode": "dynamic", // or "deterministic" for fixed slots
  "partyTypes": [
    { "value": "employer", "label": "Employer", "description": "The hiring company" },
    { "value": "employee", "label": "Employee", "description": "The person being hired" }
  ],
  "minSignatories": 2,
  "maxSignatories": 10,
  "collectFields": {
    "name": true,      // Always required
    "email": true,     // Always required  
    "title": true,     // Job title/role
    "phone": false,    // Phone number
    "company": true,   // Company name
    "address": false   // Address
  },
  "predefinedSignatories": [] // For deterministic mode
}

### DYNAMIC SCREEN CONFIGURATION

For type: "dynamic":
{
  "type": "dynamic",
  "title": "Additional Information",
  "description": "AI-generated fields based on your contract type",
  "dynamicPrompt": "Based on the {{contractType}} and {{jurisdiction}}, generate relevant fields for additional terms.",
  "dynamicMaxFields": 5
}
`;

// Base system prompt - includes role, approach, and output format
const BASE_SYSTEM_PROMPT = `You are an expert AI assistant helping to build **reusable legal document templates**. Your role is to understand the user's complete requirements through conversation, then propose a full template structure with ALL screens at once.

## CRITICAL: TEMPLATE DESIGN PHILOSOPHY

**Templates should be GENERALIZED, not specific:**
- Design for the COMMON CASE, not edge cases
- Create fields that work for ANY user of this template type
- Use generic labels like "Party A" not "John Smith's Company"
- Include helpful placeholders and helpText to guide any user

**ONLY be specific when user explicitly requests narrow use cases.**

## YOUR CONVERSATIONAL APPROACH - DISCOVERY FIRST, THEN FULL PROPOSAL

### PHASE 1: DISCOVERY (Ask questions, NO actions yet)

When user starts a new template or makes a request, have a conversation to understand the COMPLETE picture:

**Questions to explore:**
1. "What type of legal document is this?" (employment, NDA, service agreement, etc.)
2. "Who are the parties involved?" (employer/employee, company/contractor, etc.)
3. "What key information needs to be collected?" (personal details, terms, compensation, etc.)
4. "Are there any jurisdiction-specific requirements?" (Swiss law, EU, international, etc.)
5. "Any special clauses or sections needed?" (confidentiality, non-compete, IP assignment, etc.)
6. "Should we include AI-assisted form filling?" (smart suggestions based on earlier inputs)

**During discovery:**
- Ask 2-3 questions at a time, not all at once
- Use quick reply suggestions to make it easy for user to respond
- Build up your understanding of the complete template
- Keep actions array EMPTY - just ask questions

### PHASE 2: FULL TEMPLATE PROPOSAL (All screens at once)

Once you have enough context (usually after 2-3 exchanges), propose the COMPLETE template structure:

**Your proposal should include:**
- ALL screens needed for the template (typically 4-8 screens)
- Logical flow from start to finish
- AI enrichment on early screens for smart defaults later
- A signatory screen at the end for document signing
- Clear explanation of the flow and reasoning

**Example proposal message:**
"Based on our discussion, here's the complete Employment Agreement template I recommend:

1. **Employer Information** - Company details with AI enrichment to detect jurisdiction
2. **Employee Information** - Personal and contact details  
3. **Position & Compensation** - Role, salary, benefits (uses jurisdiction for currency)
4. **Working Conditions** - Hours, location, probation period
5. **Confidentiality & IP** - Standard protection clauses
6. **Signatories** - Employer and employee signatures

This flow collects all necessary information and uses AI to suggest smart defaults. Ready to create all screens?"

**When proposing, include ALL createScreen actions at once.**

### PHASE 3: REFINEMENT (After creation)

After user applies the screens, offer to:
- Add more fields to specific screens
- Adjust AI enrichment configurations
- Add additional screens if needed
- Fine-tune field options or help text

${FORM_SCHEMA_REFERENCE}

## OUTPUT FORMAT

**CRITICAL: Your ENTIRE response must be ONLY valid JSON. Start with { and end with }. No text before or after.**

{
  "message": "Your conversational response - questions during discovery OR full proposal with all screens",
  "suggestions": ["Quick reply 1", "Quick reply 2", "Quick reply 3"],
  "actions": []  // Empty during discovery, ALL screens during proposal
}

**During Discovery Phase:**
- actions: [] (empty - just asking questions)
- suggestions: Answer options for your questions

**During Proposal Phase:**
- actions: [createScreen, createScreen, createScreen, ...] (ALL screens at once)
- suggestions: ["Create all screens", "Let me adjust something", "Add more screens"]

## ACTION TYPES

1. **"createScreen"**: Creates a new screen
   - For standard: Include fields array with aiSuggestionEnabled where appropriate
   - For signatory: Include signatoryConfig with party types
   - For dynamic: Include dynamicPrompt and dynamicMaxFields
   - Include aiEnrichment on information-gathering screens

2. **"addFields"**: Adds fields to currently selected screen
   - Use during refinement phase
   - Only when user wants to modify existing screen

## ENRICHMENT STRATEGY FOR COMPLETE TEMPLATES

Design the FULL template flow for maximum AI assistance:

1. **Screen 1-2** (Party/Company Info): Collect identifying info → enrich with:
   - jurisdiction, industrySector, companySize, tradingCurrency

2. **Screen 3-5** (Terms/Details): Use enrichment for smart defaults:
   - Currency fields → aiSuggestionKey: "tradingCurrency"
   - Governing law → aiSuggestionKey: "jurisdiction"

3. **Last Screen** (Signatory): Collect signing parties
   - Configure appropriate party types for the document

## IMPORTANT RULES

1. **PURE JSON response** - no text before/after, no markdown code blocks
2. **ALL conversation in "message"** field
3. **DISCOVERY FIRST** - ask questions before creating, understand the FULL template needs
4. **PROPOSE ALL SCREENS AT ONCE** - don't create one screen at a time, propose the complete template
5. **GENERALIZED design** - templates serve many users, not specific individuals
6. **camelCase field names** - unique within screen
7. **Select fields require "options"** array
8. **AI enrichment on early screens** - generate context for smart defaults later
9. **Signatory screen last** - always end with signature collection
10. **Meaningful helpText** - explain legal implications for each field`;

// Default business logic prompt

// Default business logic prompt
const DEFAULT_BUSINESS_LOGIC_PROMPT = `You are helping build legal document templates. Follow these guidelines:
- Create logical screen groupings (e.g., Party Information, Terms, Conditions)
- Each screen should have 3-6 fields for optimal user experience
- Include helpful descriptions for complex legal fields
- Suggest appropriate field types based on the data being collected
- Consider jurisdiction-specific requirements when relevant
- Use clear, professional language for labels and help text
- Ensure field names follow camelCase convention`;

// Request validation schema
const requestSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(["user", "assistant"]),
      content: z.string(),
    })
  ),
  templateContext: z.object({
    templateId: z.string(),
    templateTitle: z.string(),
    templateDescription: z.string().optional(),
    screens: z.array(
      z.object({
        id: z.string(),
        title: z.string(),
        description: z.string().nullable().optional(),
        order: z.number(),
        aiPrompt: z.string().nullable().optional(),
        aiOutputSchema: z.string().nullable().optional(),
        fields: z.array(
          z.object({
            name: z.string(),
            label: z.string(),
            type: z.string(),
            required: z.boolean(),
            placeholder: z.string().nullable().optional(),
            helpText: z.string().nullable().optional(),
            options: z.array(z.string()).optional(),
          })
        ),
      })
    ),
  }),
  selectedScreenId: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validation = requestSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: "Validation failed", details: validation.error.format() },
        { status: 400 }
      );
    }

    const { messages, templateContext, selectedScreenId } = validation.data;

    // Get session ID for analytics
    const sessionId = await getSessionId();

    // Fetch AI model from settings
    const aiModelSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorAiModel" },
    });
    const aiModel = aiModelSetting?.value || DEFAULT_CONFIGURATOR_MODEL;

    // Fetch business logic prompt from settings
    const businessLogicSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorBusinessLogic" },
    });
    const businessLogicPrompt =
      businessLogicSetting?.value || DEFAULT_BUSINESS_LOGIC_PROMPT;

    // Find selected screen if specified
    const selectedScreen = selectedScreenId
      ? templateContext.screens.find((s) => s.id === selectedScreenId)
      : null;

    // Build the full system prompt
    const systemPrompt = `${BASE_SYSTEM_PROMPT}

## CURRENT TEMPLATE CONTEXT

Template: ${templateContext.templateTitle}
${templateContext.templateDescription ? `Description: ${templateContext.templateDescription}` : ""}

## EXISTING SCREENS (${templateContext.screens.length} total)

${
  templateContext.screens.length === 0
    ? "No screens have been created yet."
    : templateContext.screens
        .map(
          (screen, idx) => {
            let screenInfo = `
### Screen ${idx + 1}: ${screen.title}
${screen.description ? `Description: ${screen.description}` : ""}
Fields (${screen.fields.length}):
${
  screen.fields.length === 0
    ? "  - No fields yet"
    : screen.fields
        .map(
          (f) =>
            `  - ${f.name} (${f.type}${f.required ? ", required" : ""}): "${f.label}"`
        )
        .join("\n")
}`;
            // Add enrichment info if present
            if (screen.aiOutputSchema) {
              try {
                const schema = JSON.parse(screen.aiOutputSchema);
                if (schema.properties) {
                  const outputVars = Object.keys(schema.properties);
                  screenInfo += `\nAI Enrichment outputs: ${outputVars.join(", ")}`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            return screenInfo;
          }
        )
        .join("\n")
}

## AVAILABLE ENRICHMENT VARIABLES FOR aiSuggestionKey

${(() => {
  const availableVars: string[] = [];
  templateContext.screens.forEach((screen) => {
    if (screen.aiOutputSchema) {
      try {
        const schema = JSON.parse(screen.aiOutputSchema);
        if (schema.properties) {
          Object.keys(schema.properties).forEach((key) => {
            availableVars.push(key);
          });
        }
      } catch (e) {
        // Ignore parse errors
      }
    }
  });
  return availableVars.length > 0
    ? `These variables are available from previous screen enrichments: ${availableVars.join(", ")}\nUse these as aiSuggestionKey values for fields in new screens.`
    : "No enrichment variables available yet. Consider adding AI enrichment to early screens to generate context variables.";
})()}

${
  selectedScreen
    ? `
## CURRENTLY SELECTED SCREEN

The user has selected "${selectedScreen.title}" - if they ask to add fields, add them to this screen using the "addFields" action type.
`
    : `
## NO SCREEN SELECTED

If the user asks to add fields to an existing screen, remind them to select a screen first, or suggest creating a new screen.
`
}

## ADMIN BUSINESS LOGIC INSTRUCTIONS

${businessLogicPrompt}`;

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] System prompt length:", systemPrompt.length);
      console.log("[TEMPLATE_CONFIGURATOR] Messages count:", messages.length);
      console.log("[TEMPLATE_CONFIGURATOR] Using model:", aiModel);
    }

    // Build conversation messages
    const conversationMessages = [
      { role: "system" as const, content: systemPrompt },
      ...messages.map((m) => ({
        role: m.role as "user" | "assistant",
        content: m.content,
      })),
    ];

    // Call OpenRouter
    const completion = await createCompletionWithTracking(
      {
        model: aiModel,
        messages: conversationMessages,
        response_format: { type: "json_object" },
        temperature: 0.7,
        max_tokens: 4096,
      },
      {
        sessionId,
        endpoint: "/api/ai/template-configurator",
      }
    );

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error("No content received from AI");
    }

    // Parse and validate the response
    let response;
    try {
      // First try direct JSON parsing
      response = JSON.parse(content);
    } catch (parseError) {
      // If direct parsing fails, try to extract JSON from markdown code blocks
      const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
      if (jsonMatch && jsonMatch[1]) {
        try {
          response = JSON.parse(jsonMatch[1].trim());
          if (process.env.NODE_ENV === "development") {
            console.log("[TEMPLATE_CONFIGURATOR] Extracted JSON from markdown code block");
          }
        } catch (innerParseError) {
          console.error("[TEMPLATE_CONFIGURATOR] Failed to parse extracted JSON:", jsonMatch[1]);
          throw new Error("AI returned invalid JSON");
        }
      } else {
        // Try to find JSON object pattern in the response
        const objectMatch = content.match(/\{[\s\S]*"message"[\s\S]*\}/);
        if (objectMatch) {
          try {
            response = JSON.parse(objectMatch[0]);
            if (process.env.NODE_ENV === "development") {
              console.log("[TEMPLATE_CONFIGURATOR] Extracted JSON object from response");
            }
          } catch (innerParseError) {
            console.error("[TEMPLATE_CONFIGURATOR] Failed to parse AI response:", content);
            throw new Error("AI returned invalid JSON");
          }
        } else {
          console.error("[TEMPLATE_CONFIGURATOR] Failed to parse AI response:", content);
          throw new Error("AI returned invalid JSON");
        }
      }
    }

    // Ensure response has required structure
    if (!response.message) {
      response.message = "I've processed your request.";
    }
    if (!response.actions) {
      response.actions = [];
    }

    // Validate actions structure
    response.actions = response.actions.filter((action: any) => {
      if (!action.type || !action.data) return false;
      if (action.type === "createScreen") {
        // Must have a title
        if (!action.data.title) return false;
        
        const screenType = action.data.type || "standard";
        
        // Validate based on screen type
        if (screenType === "standard") {
          // Standard screens should have fields array (can be empty)
          return Array.isArray(action.data.fields);
        } else if (screenType === "signatory") {
          // Signatory screens need signatoryConfig
          return action.data.signatoryConfig !== undefined;
        } else if (screenType === "dynamic") {
          // Dynamic screens need dynamicPrompt
          return action.data.dynamicPrompt !== undefined;
        }
        
        // Default: accept if has title
        return true;
      }
      if (action.type === "addFields") {
        return Array.isArray(action.data);
      }
      return false;
    });

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] Response:", {
        message: response.message.substring(0, 100) + "...",
        actionsCount: response.actions.length,
      });
    }

    return NextResponse.json(response);
  } catch (error) {
    console.error("[TEMPLATE_CONFIGURATOR]", error);
    return NextResponse.json(
      {
        error: "Failed to process request",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
