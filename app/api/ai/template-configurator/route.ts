import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { createCompletionWithTracking } from "@/lib/openrouter";
import { getSessionId } from "@/lib/analytics/session";
import { prisma } from "@/lib/db";

// Default model if not configured in settings
const DEFAULT_CONFIGURATOR_MODEL = "anthropic/claude-sonnet-4";

// ============================================================================
// DYNAMIC SCHEMA REFERENCE - This is the complete form builder capability
// ============================================================================

const FORM_SCHEMA_REFERENCE = `
## COMPLETE FORM BUILDER SCHEMA

You have access to a powerful form builder system. Here's everything you can create:

### SCREEN TYPES

1. **standard** (default): Regular form screen with custom fields
   - Most common type for collecting user input
   - Supports all field types and AI enrichment
   - Use for: Party info, contract terms, compensation details, etc.

2. **signatory**: Special screen for collecting signatory/party information
   - Pre-built UI for managing multiple signatories
   - Supports: name, email, title, phone, company, address
   - Modes: "deterministic" (fixed slots) or "dynamic" (user adds/removes)
   - Use for: Collecting parties who will sign the document

3. **dynamic**: AI-generated screen with fields created on-the-fly
   - Fields are generated by AI based on context from previous screens
   - Useful for conditional/context-dependent data collection
   - Requires: dynamicPrompt (AI instructions), dynamicMaxFields (limit)

### FIELD TYPES (for standard screens)

| Type | Description | Use Case |
|------|-------------|----------|
| text | Single-line text input | Names, titles, addresses, general text |
| email | Email with validation | Contact emails, notification addresses |
| date | Date picker | Start dates, end dates, deadlines |
| number | Numeric input | Salaries, amounts, quantities, percentages |
| checkbox | Boolean yes/no | Agreements, optional clauses, confirmations |
| select | Dropdown with options | Fixed choices (countries, currencies, types) |

### FIELD PROPERTIES

Required:
- name: camelCase identifier (unique within screen)
- label: Human-readable display label
- type: One of the field types above
- required: Boolean - whether field must be filled

Optional:
- placeholder: Hint text shown in empty input
- helpText: Explanation text below field (great for legal context)
- options: String array (REQUIRED for select type)
- aiSuggestionEnabled: Boolean - enable AI auto-fill from enrichment context
- aiSuggestionKey: String - key from previous screen's AI enrichment output

### SCREEN PROPERTIES

Required:
- title: Screen heading
- fields: Array of field objects (for standard type)

Optional:
- description: Helper text explaining the screen's purpose
- type: "standard" | "signatory" | "dynamic" (defaults to standard)
- aiEnrichment: Object with prompt and outputSchema (for AI context generation)
- enableApplyStandards: Boolean - enables one-click "Apply Standards" button for AI suggestions

For signatory screens:
- signatoryConfig: { mode, partyTypes, minSignatories, maxSignatories, collectFields, predefinedSignatories }

For dynamic screens:
- dynamicPrompt: AI instructions to generate fields
- dynamicMaxFields: Maximum fields to generate (default: 5)

### AI ENRICHMENT SYSTEM

The AI Enrichment system creates intelligent form auto-fill:

1. **Screen Enrichment Prompt**: Runs after screen completion
   - Reference fields with {{fieldName}} syntax
   - Analyzes user inputs to infer additional context (runs in background)

2. **Output Schema**: Defines context variables generated
   - JSON Schema format with properties and types
   - These become available for later screens' aiSuggestionKey

3. **Field AI Suggestions**: Auto-populate from enrichment
   - Set aiSuggestionEnabled: true
   - Set aiSuggestionKey: "propertyNameFromSchema"
   - User sees suggested value they can accept or modify

### APPLY STANDARDS FEATURE (KEY FOR FRICTIONLESS UX)

**enableApplyStandards: true** enables a one-click "Apply Standards" button on screens:
- When user reaches this screen, they see a prominent button
- One click fills ALL fields that have AI suggestions configured
- Dramatically reduces manual data entry

**STRATEGIC USE:**
- Enable on screens AFTER enrichment has run (Screen 3+)
- Only works if fields have aiSuggestionEnabled + aiSuggestionKey
- Perfect for: compensation screens, terms screens, condition screens

**Example screen with Apply Standards:**
{
  "title": "Compensation & Benefits",
  "enableApplyStandards": true,
  "fields": [
    { "name": "currency", "label": "Currency", "type": "select", "options": ["CHF", "EUR", "USD"], "aiSuggestionEnabled": true, "aiSuggestionKey": "tradingCurrency" },
    { "name": "annualSalary", "label": "Annual Salary", "type": "number", "aiSuggestionEnabled": true, "aiSuggestionKey": "marketSalaryRange" },
    { "name": "bonusPercentage", "label": "Bonus %", "type": "number", "aiSuggestionEnabled": true, "aiSuggestionKey": "standardBonusRate" }
  ]
}

### SIGNATORY SCREEN CONFIGURATION

For type: "signatory", use signatoryConfig:
{
  "mode": "dynamic", // or "deterministic" for fixed slots
  "partyTypes": [
    { "value": "employer", "label": "Employer", "description": "The hiring company" },
    { "value": "employee", "label": "Employee", "description": "The person being hired" }
  ],
  "minSignatories": 2,
  "maxSignatories": 10,
  "collectFields": {
    "name": true,      // Always required
    "email": true,     // Always required  
    "title": true,     // Job title/role
    "phone": false,    // Phone number
    "company": true,   // Company name
    "address": false   // Address
  },
  "predefinedSignatories": [] // For deterministic mode
}

### DYNAMIC SCREEN CONFIGURATION

For type: "dynamic":
{
  "type": "dynamic",
  "title": "Additional Information",
  "description": "AI-generated fields based on your contract type",
  "dynamicPrompt": "Based on the {{contractType}} and {{jurisdiction}}, generate relevant fields for additional terms.",
  "dynamicMaxFields": 5
}
`;

// Base system prompt - includes role, approach, and output format
const BASE_SYSTEM_PROMPT = `You are an expert AI assistant helping to build **reusable legal document templates**. Your role is to understand the user's complete requirements through conversation, then propose a full template structure with ALL screens at once.

## CRITICAL: TEMPLATE DESIGN PHILOSOPHY

**Templates should be GENERALIZED, not specific:**
- Design for the COMMON CASE, not edge cases
- Create fields that work for ANY user of this template type
- Use generic labels like "Party A" not "John Smith's Company"
- Include helpful placeholders and helpText to guide any user

**ONLY be specific when user explicitly requests narrow use cases.**

## YOUR CONVERSATIONAL APPROACH - DISCOVERY FIRST, THEN FULL PROPOSAL

### PHASE 1: DISCOVERY (Ask questions, NO actions yet)

When user starts a new template or makes a request, have a conversation to understand the COMPLETE picture:

**Questions to explore:**
1. "What type of legal document is this?" (employment, NDA, service agreement, etc.)
2. "Who are the parties involved?" (employer/employee, company/contractor, etc.)
3. "What key information needs to be collected?" (personal details, terms, compensation, etc.)
4. "Are there any jurisdiction-specific requirements?" (Swiss law, EU, international, etc.)
5. "Any special clauses or sections needed?" (confidentiality, non-compete, IP assignment, etc.)
6. "Should we include AI-assisted form filling?" (smart suggestions based on earlier inputs)

**During discovery:**
- Ask 2-3 questions at a time, not all at once
- Use quick reply suggestions to make it easy for user to respond
- Build up your understanding of the complete template
- Keep actions array EMPTY - just ask questions

### PHASE 2: FULL TEMPLATE PROPOSAL (All screens at once)

Once you have enough context (usually after 2-3 exchanges), propose the COMPLETE template structure:

**Your proposal should include:**
- ALL screens needed for the template (typically 4-8 screens)
- Logical flow from start to finish
- AI enrichment on early screens for smart defaults later
- A signatory screen at the end for document signing
- Clear explanation of the flow and reasoning

**Example proposal message:**
"Based on our discussion, here's the complete Employment Agreement template I recommend:

1. **Employer Information** - Company details with AI enrichment to detect jurisdiction
2. **Employee Information** - Personal and contact details  
3. **Position & Compensation** - Role, salary, benefits (uses jurisdiction for currency)
4. **Working Conditions** - Hours, location, probation period
5. **Confidentiality & IP** - Standard protection clauses
6. **Signatories** - Employer and employee signatures

This flow collects all necessary information and uses AI to suggest smart defaults. Ready to create all screens?"

**When proposing, include ALL createScreen actions at once.**

### PHASE 3: REFINEMENT (After creation)

After user applies the screens, offer to:
- Add more fields to specific screens
- Adjust AI enrichment configurations
- Add additional screens if needed
- Fine-tune field options or help text

${FORM_SCHEMA_REFERENCE}

## OUTPUT FORMAT

**CRITICAL: Your ENTIRE response must be ONLY valid JSON. Start with { and end with }. No text before or after.**

{
  "message": "Your conversational response - questions during discovery OR full proposal with all screens",
  "suggestions": ["Quick reply 1", "Quick reply 2", "Quick reply 3"],
  "actions": []  // Empty during discovery, ALL screens during proposal
}

**During Discovery Phase:**
- actions: [] (empty - just asking questions)
- suggestions: Answer options for your questions

**During Proposal Phase:**
- actions: [createScreen, createScreen, createScreen, ...] (ALL screens at once)
- suggestions: ["Create all screens", "Let me adjust something", "Add more screens"]

## ACTION TYPES

1. **"createScreen"**: Creates a new screen
   - For standard: Include fields array with aiSuggestionEnabled where appropriate
   - For signatory: Include signatoryConfig with party types
   - For dynamic: Include dynamicPrompt and dynamicMaxFields
   - Include aiEnrichment on information-gathering screens

2. **"addFields"**: Adds fields to currently selected screen
   - Use during refinement phase
   - Only when user wants to modify existing screen

## STRATEGIC FLOW DESIGN FOR FRICTIONLESS UX

**PRIORITY: Minimize user effort while maintaining legal quality**

Design templates to maximize AI-assisted form filling:

### OPTIMAL SCREEN FLOW PATTERN:

**Screen 1: Essential Input + Enrichment**
- Collect MINIMAL essential info (company name, address, role, etc.)
- Add aiEnrichment to infer: jurisdiction, industry, currency, market standards
- User must fill this manually (it's the seed data for AI)

**Screen 2: Secondary Info (Buffer Screen)**
- Collect additional required info that user must provide
- AI enrichment runs in background while user fills this
- Can also add enrichment here for more context

**Screen 3+: AI-Assisted Screens (enableApplyStandards: true)**
- Enable "Apply Standards" button
- Most/all fields have aiSuggestionEnabled + aiSuggestionKey
- User clicks ONE button to fill multiple fields at once
- They can review and adjust if needed

**Last Screen: Signatories**
- Collect signing parties
- Standard signatory screen configuration

### EXAMPLE EMPLOYMENT AGREEMENT FLOW:

1. **Employer Info** (aiEnrichment â†’ jurisdiction, industry, companySize, currency, salaryRange)
2. **Employee Info** (user fills while enrichment runs)
3. **Position Details** (enableApplyStandards: true, fields use enrichment)
4. **Compensation** (enableApplyStandards: true, salary/benefits from enrichment)
5. **Working Conditions** (enableApplyStandards: true)
6. **Confidentiality** (standard clauses, minimal AI needed)
7. **Signatories** (employer + employee)

### ENRICHMENT OUTPUT RECOMMENDATIONS:

From company/party info, generate:
- jurisdiction, tradingCurrency, industrySector
- companySize, companyType, operatingRegions

From role/position info, generate:
- employmentType, seniorityLevel, departmentType
- marketSalaryRange, standardBenefits, typicalProbationPeriod

## IMPORTANT RULES

1. **PURE JSON response** - no text before/after, no markdown code blocks
2. **ALL conversation in "message"** field
3. **DISCOVERY FIRST** - ask questions before creating, understand the FULL template needs
4. **PROPOSE ALL SCREENS AT ONCE** - don't create one screen at a time, propose the complete template
5. **MAXIMIZE APPLY STANDARDS** - enable on screens 3+ where enrichment data is available
6. **FRICTIONLESS FLOW** - early screens collect data, later screens auto-fill
7. **GENERALIZED design** - templates serve many users, not specific individuals
8. **camelCase field names** - unique within screen
9. **Select fields require "options"** array
10. **AI enrichment on screens 1-2** - generate context for smart defaults later
11. **Fields with aiSuggestionKey** - enable aiSuggestionEnabled: true
12. **Signatory screen last** - always end with signature collection`;

// Default business logic prompt

// Default business logic prompt
const DEFAULT_BUSINESS_LOGIC_PROMPT = `You are helping build legal document templates. Follow these guidelines:
- Create logical screen groupings (e.g., Party Information, Terms, Conditions)
- Each screen should have 3-6 fields for optimal user experience
- Include helpful descriptions for complex legal fields
- Suggest appropriate field types based on the data being collected
- Consider jurisdiction-specific requirements when relevant
- Use clear, professional language for labels and help text
- Ensure field names follow camelCase convention`;

// Request validation schema
const requestSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(["user", "assistant"]),
      content: z.string(),
    })
  ),
  templateContext: z.object({
    templateId: z.string(),
    templateTitle: z.string(),
    templateDescription: z.string().optional(),
    screens: z.array(
      z.object({
        id: z.string(),
        title: z.string(),
        description: z.string().nullable().optional(),
        order: z.number(),
        aiPrompt: z.string().nullable().optional(),
        aiOutputSchema: z.string().nullable().optional(),
        fields: z.array(
          z.object({
            name: z.string(),
            label: z.string(),
            type: z.string(),
            required: z.boolean(),
            placeholder: z.string().nullable().optional(),
            helpText: z.string().nullable().optional(),
            options: z.array(z.string()).optional(),
          })
        ),
      })
    ),
  }),
  selectedScreenId: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validation = requestSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: "Validation failed", details: validation.error.format() },
        { status: 400 }
      );
    }

    const { messages, templateContext, selectedScreenId } = validation.data;

    // Get session ID for analytics
    const sessionId = await getSessionId();

    // Fetch AI model from settings
    const aiModelSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorAiModel" },
    });
    const aiModel = aiModelSetting?.value || DEFAULT_CONFIGURATOR_MODEL;

    // Fetch business logic prompt from settings
    const businessLogicSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorBusinessLogic" },
    });
    const businessLogicPrompt =
      businessLogicSetting?.value || DEFAULT_BUSINESS_LOGIC_PROMPT;

    // Find selected screen if specified
    const selectedScreen = selectedScreenId
      ? templateContext.screens.find((s) => s.id === selectedScreenId)
      : null;

    // Build the full system prompt
    const systemPrompt = `${BASE_SYSTEM_PROMPT}

## CURRENT TEMPLATE CONTEXT

Template: ${templateContext.templateTitle}
${templateContext.templateDescription ? `Description: ${templateContext.templateDescription}` : ""}

## EXISTING SCREENS (${templateContext.screens.length} total)

${
  templateContext.screens.length === 0
    ? "No screens have been created yet."
    : templateContext.screens
        .map(
          (screen, idx) => {
            let screenInfo = `
### Screen ${idx + 1}: ${screen.title}
${screen.description ? `Description: ${screen.description}` : ""}
Fields (${screen.fields.length}):
${
  screen.fields.length === 0
    ? "  - No fields yet"
    : screen.fields
        .map(
          (f) =>
            `  - ${f.name} (${f.type}${f.required ? ", required" : ""}): "${f.label}"`
        )
        .join("\n")
}`;
            // Add enrichment info if present
            if (screen.aiOutputSchema) {
              try {
                const schema = JSON.parse(screen.aiOutputSchema);
                if (schema.properties) {
                  const outputVars = Object.keys(schema.properties);
                  screenInfo += `\nAI Enrichment outputs: ${outputVars.join(", ")}`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            return screenInfo;
          }
        )
        .join("\n")
}

## AVAILABLE ENRICHMENT VARIABLES FOR aiSuggestionKey

${(() => {
  const availableVars: string[] = [];
  templateContext.screens.forEach((screen) => {
    if (screen.aiOutputSchema) {
      try {
        const schema = JSON.parse(screen.aiOutputSchema);
        if (schema.properties) {
          Object.keys(schema.properties).forEach((key) => {
            availableVars.push(key);
          });
        }
      } catch (e) {
        // Ignore parse errors
      }
    }
  });
  return availableVars.length > 0
    ? `These variables are available from previous screen enrichments: ${availableVars.join(", ")}\nUse these as aiSuggestionKey values for fields in new screens.`
    : "No enrichment variables available yet. Consider adding AI enrichment to early screens to generate context variables.";
})()}

${
  selectedScreen
    ? `
## CURRENTLY SELECTED SCREEN

The user has selected "${selectedScreen.title}" - if they ask to add fields, add them to this screen using the "addFields" action type.
`
    : `
## NO SCREEN SELECTED

If the user asks to add fields to an existing screen, remind them to select a screen first, or suggest creating a new screen.
`
}

## ADMIN BUSINESS LOGIC INSTRUCTIONS

${businessLogicPrompt}`;

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] System prompt length:", systemPrompt.length);
      console.log("[TEMPLATE_CONFIGURATOR] Messages count:", messages.length);
      console.log("[TEMPLATE_CONFIGURATOR] Using model:", aiModel);
    }

    // Build conversation messages
    const conversationMessages = [
      { role: "system" as const, content: systemPrompt },
      ...messages.map((m) => ({
        role: m.role as "user" | "assistant",
        content: m.content,
      })),
    ];

    // Call OpenRouter
    const completion = await createCompletionWithTracking(
      {
        model: aiModel,
        messages: conversationMessages,
        response_format: { type: "json_object" },
        temperature: 0.7,
        max_tokens: 16384, // Increased for comprehensive multi-screen templates
      },
      {
        sessionId,
        endpoint: "/api/ai/template-configurator",
      }
    );

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error("No content received from AI");
    }

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] Raw response length:", content.length);
      console.log("[TEMPLATE_CONFIGURATOR] Response starts with:", content.substring(0, 100));
      console.log("[TEMPLATE_CONFIGURATOR] Response ends with:", content.substring(content.length - 100));
    }

    // Helper function to repair truncated JSON
    const repairTruncatedJson = (jsonStr: string): string | null => {
      // Count open braces/brackets
      let braceCount = 0;
      let bracketCount = 0;
      let inString = false;
      let escapeNext = false;
      
      for (let i = 0; i < jsonStr.length; i++) {
        const char = jsonStr[i];
        
        if (escapeNext) {
          escapeNext = false;
          continue;
        }
        
        if (char === '\\' && inString) {
          escapeNext = true;
          continue;
        }
        
        if (char === '"' && !escapeNext) {
          inString = !inString;
          continue;
        }
        
        if (!inString) {
          if (char === '{') braceCount++;
          if (char === '}') braceCount--;
          if (char === '[') bracketCount++;
          if (char === ']') bracketCount--;
        }
      }
      
      // If we're still in a string, try to close it
      let repaired = jsonStr;
      if (inString) {
        // Find the last valid position and truncate incomplete string
        const lastQuoteIdx = repaired.lastIndexOf('"');
        if (lastQuoteIdx > 0) {
          // Check if this quote starts an incomplete string value
          const beforeQuote = repaired.substring(0, lastQuoteIdx);
          const colonIdx = beforeQuote.lastIndexOf(':');
          if (colonIdx !== -1 && colonIdx > beforeQuote.lastIndexOf('}') && colonIdx > beforeQuote.lastIndexOf(']')) {
            // We're in the middle of a string value, truncate it
            repaired = repaired.substring(0, lastQuoteIdx) + '"';
            inString = false;
          }
        }
        if (inString) {
          repaired += '"';
        }
      }
      
      // Close unclosed brackets and braces
      repaired += ']'.repeat(Math.max(0, bracketCount));
      repaired += '}'.repeat(Math.max(0, braceCount));
      
      return repaired;
    };

    // Parse and validate the response
    let response;
    try {
      // First try direct JSON parsing
      response = JSON.parse(content);
    } catch (parseError) {
      if (process.env.NODE_ENV === "development") {
        console.log("[TEMPLATE_CONFIGURATOR] Direct parse failed, trying repair methods...");
      }
      
      // Try to repair truncated JSON (common when max_tokens is hit)
      const repaired = repairTruncatedJson(content);
      if (repaired) {
        try {
          response = JSON.parse(repaired);
          if (process.env.NODE_ENV === "development") {
            console.log("[TEMPLATE_CONFIGURATOR] Parsed JSON after repair");
          }
        } catch (repairError) {
          if (process.env.NODE_ENV === "development") {
            console.log("[TEMPLATE_CONFIGURATOR] Repair failed, trying other methods...");
          }
        }
      }
      
      // If repair didn't work, try to extract JSON from markdown code blocks
      if (!response) {
        const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (jsonMatch && jsonMatch[1]) {
          const repairedBlock = repairTruncatedJson(jsonMatch[1].trim());
          if (repairedBlock) {
            try {
              response = JSON.parse(repairedBlock);
              if (process.env.NODE_ENV === "development") {
                console.log("[TEMPLATE_CONFIGURATOR] Extracted and repaired JSON from markdown code block");
              }
            } catch (innerParseError) {
              // Continue to next method
            }
          }
        }
      }
      
      // Final fallback: create a response explaining the truncation
      if (!response) {
        console.error("[TEMPLATE_CONFIGURATOR] All parse methods failed. Content length:", content.length);
        console.error("[TEMPLATE_CONFIGURATOR] Last 200 chars:", content.substring(content.length - 200));
        
        // Check if this looks like truncated JSON (has opening { but response is long)
        const isTruncated = content.startsWith('{') && content.length > 5000 && !content.trim().endsWith('}');
        
        if (isTruncated) {
          response = {
            message: "My response was too long and got cut off. Let me create a simpler version with fewer screens. Would you like me to try again with a more compact template, or should I create the screens one at a time?",
            suggestions: ["Create compact version", "Create screens one at a time", "Try again"],
            actions: []
          };
        } else {
          response = {
            message: "I had trouble formatting my response. Could you please try again?",
            suggestions: ["Try again", "Start over", "Create a simple template"],
            actions: []
          };
        }
      }
    }

    // Ensure response has required structure
    if (!response.message) {
      response.message = "I've processed your request.";
    }
    if (!response.actions) {
      response.actions = [];
    }

    // Validate actions structure
    response.actions = response.actions.filter((action: any) => {
      if (!action.type || !action.data) return false;
      if (action.type === "createScreen") {
        // Must have a title
        if (!action.data.title) return false;
        
        const screenType = action.data.type || "standard";
        
        // Validate based on screen type
        if (screenType === "standard") {
          // Standard screens should have fields array (can be empty)
          return Array.isArray(action.data.fields);
        } else if (screenType === "signatory") {
          // Signatory screens need signatoryConfig
          return action.data.signatoryConfig !== undefined;
        } else if (screenType === "dynamic") {
          // Dynamic screens need dynamicPrompt
          return action.data.dynamicPrompt !== undefined;
        }
        
        // Default: accept if has title
        return true;
      }
      if (action.type === "addFields") {
        return Array.isArray(action.data);
      }
      return false;
    });

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] Response:", {
        message: response.message.substring(0, 100) + "...",
        actionsCount: response.actions.length,
      });
    }

    return NextResponse.json(response);
  } catch (error) {
    console.error("[TEMPLATE_CONFIGURATOR]", error);
    return NextResponse.json(
      {
        error: "Failed to process request",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
