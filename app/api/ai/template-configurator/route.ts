import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { jsonrepair } from "jsonrepair";
import { createCompletionWithTracking } from "@/lib/openrouter";
import { getSessionId } from "@/lib/analytics/session";
import { prisma } from "@/lib/db";
import { generateFieldTypeGuide, generateFieldExamples } from "@/lib/field-type-intelligence";

// Default model if not configured in settings
const DEFAULT_CONFIGURATOR_MODEL = "anthropic/claude-sonnet-4";

// ============================================================================
// DYNAMIC SCHEMA REFERENCE - This is the complete form builder capability
// ============================================================================

const FORM_SCHEMA_REFERENCE = `
## COMPLETE FORM BUILDER SCHEMA

You have access to a powerful form builder system. Here's everything you can create:

### SCREEN TYPES

1. **standard** (default): Regular form screen with custom fields
   - Most common type for collecting user input
   - Supports all field types and AI enrichment
   - Use for: Party info, contract terms, compensation details, etc.

2. **signatory**: Special screen for collecting signatory/party information
   - Pre-built UI for managing multiple signatories
   - Supports: name, email, title, phone, company, address
   - Modes: "deterministic" (fixed slots) or "dynamic" (user adds/removes)
   - Use for: Collecting parties who will sign the document

3. **dynamic**: AI-generated screen with fields created on-the-fly
   - Fields are generated by AI based on context from previous screens
   - Useful for conditional/context-dependent data collection
   - Requires: dynamicPrompt (AI instructions), dynamicMaxFields (limit)

### FIELD TYPES (for standard screens)

**COMPOSITE FIELDS (Use for complex data - PREFERRED):**

| Type | Description | Use Case | Data Structure |
|------|-------------|----------|----------------|
| party | Name + full address composite | Employer, employee, contractor, vendor, any legal party | { name, street, city, state, postalCode, country } |
| address | Physical address composite | Mailing address, work location, billing address | { street, city, state, postalCode, country } |
| phone | Phone with country code | Contact phone, mobile, fax | { countryCode, number } |
| currency | Amount + currency selector | Salary, fees, prices, payments | { amount, currency } |

**SPECIALIZED FIELDS:**

| Type | Description | Use Case |
|------|-------------|----------|
| percentage | 0-100 with % display | Bonus rates, commission, equity share |
| url | URL with validation | Website, LinkedIn, portfolio |
| textarea | Multi-line text input | Job description, notes, responsibilities |

**BASIC FIELDS:**

| Type | Description | Use Case |
|------|-------------|----------|
| text | Single-line text input | Names, titles, IDs, short text |
| email | Email with validation | Contact emails, notification addresses |
| date | Date picker | Start dates, end dates, deadlines |
| number | Numeric input (NOT for money!) | Counts, quantities, durations |
| checkbox | Boolean yes/no | Agreements, optional clauses, confirmations |
| select | Dropdown with options | Fixed choices (employment type, categories) |

**CRITICAL FIELD TYPE RULES:**
- **NEVER use "text" for addresses** → Use "party" or "address"
- **NEVER use "number" for money/salary** → Use "currency"
- **NEVER use "text" for phones** → Use "phone"
- **NEVER use "text" for long descriptions** → Use "textarea"
- **Use "party" for any entity** that needs name + address (employer, employee, etc.)

### FIELD PROPERTIES

Required:
- name: camelCase identifier (unique within screen)
- label: Human-readable display label
- type: One of the field types above (use composite types for complex data!)
- required: Boolean - whether field must be filled

Optional:
- placeholder: Hint text shown in empty input
- helpText: Explanation text below field (great for legal context)
- options: String array (REQUIRED for select type)
- aiSuggestionEnabled: Boolean - enable AI auto-fill from enrichment context
- aiSuggestionKey: String - key from previous screen's AI enrichment output

### COMPOSITE FIELD VALUE STRUCTURES

When AI enrichment outputs values for composite fields, use these structures:

**party** (name + address):
\`\`\`json
{
  "name": "ACME Corporation",
  "street": "123 Business Ave",
  "city": "Zurich",
  "state": "ZH",
  "postalCode": "8001",
  "country": "CH"
}
\`\`\`

**address** (address only):
\`\`\`json
{
  "street": "456 Worker Lane",
  "city": "Geneva",
  "state": "GE",
  "postalCode": "1200",
  "country": "CH"
}
\`\`\`

**currency** (amount + currency):
\`\`\`json
{
  "amount": 120000,
  "currency": "CHF"
}
\`\`\`

**phone** (country code + number):
\`\`\`json
{
  "countryCode": "+41",
  "number": "44 123 4567"
}
\`\`\`

### SCREEN PROPERTIES

Required:
- title: Screen heading
- fields: Array of field objects (for standard type)

Optional:
- description: Helper text explaining the screen's purpose
- type: "standard" | "signatory" | "dynamic" (defaults to standard)
- aiEnrichment: Object with prompt and outputSchema (for AI context generation)
- enableApplyStandards: Boolean - enables one-click "Apply Standards" button for AI suggestions

For signatory screens:
- signatoryConfig: { mode, partyTypes, minSignatories, maxSignatories, collectFields, predefinedSignatories }

For dynamic screens:
- dynamicPrompt: AI instructions to generate fields
- dynamicMaxFields: Maximum fields to generate (default: 5)

### AI ENRICHMENT SYSTEM

The AI Enrichment system creates intelligent form auto-fill:

1. **Screen Enrichment Prompt**: Runs after screen completion
   - Reference fields with {{fieldName}} syntax
   - Analyzes user inputs to infer additional context (runs in background)

2. **Output Schema**: Defines context variables generated
   - JSON Schema format with properties and types
   - These become available for later screens' aiSuggestionKey

3. **Field AI Suggestions**: Auto-populate from enrichment
   - Set aiSuggestionEnabled: true
   - Set aiSuggestionKey: "propertyNameFromSchema"
   - User sees suggested value they can accept or modify

### APPLY STANDARDS FEATURE (KEY FOR FRICTIONLESS UX)

**enableApplyStandards: true** enables a one-click "Apply Standards" button on screens:
- When user reaches this screen, they see a prominent button
- One click fills ALL fields that have AI suggestions configured
- Dramatically reduces manual data entry

**STRATEGIC USE:**
- Enable on screens AFTER enrichment has run (Screen 3+)
- Only works if fields have aiSuggestionEnabled + aiSuggestionKey
- Perfect for: compensation screens, terms screens, condition screens

**Example screen with Apply Standards:**
{
  "title": "Compensation & Benefits",
  "enableApplyStandards": true,
  "fields": [
    { "name": "currency", "label": "Currency", "type": "select", "options": ["CHF", "EUR", "USD"], "aiSuggestionEnabled": true, "aiSuggestionKey": "tradingCurrency" },
    { "name": "annualSalary", "label": "Annual Salary", "type": "number", "aiSuggestionEnabled": true, "aiSuggestionKey": "marketSalaryRange" },
    { "name": "bonusPercentage", "label": "Bonus %", "type": "number", "aiSuggestionEnabled": true, "aiSuggestionKey": "standardBonusRate" }
  ]
}

### SIGNATORY SCREEN CONFIGURATION

For type: "signatory", use signatoryConfig:
{
  "mode": "dynamic", // or "deterministic" for fixed slots
  "partyTypes": [
    { "value": "employer", "label": "Employer", "description": "The hiring company" },
    { "value": "employee", "label": "Employee", "description": "The person being hired" }
  ],
  "minSignatories": 2,
  "maxSignatories": 10,
  "collectFields": {
    "name": true,      // Always required
    "email": true,     // Always required  
    "title": true,     // Job title/role
    "phone": false,    // Phone number
    "company": true,   // Company name
    "address": false   // Address
  },
  "predefinedSignatories": [] // For deterministic mode
}

### DYNAMIC SCREEN CONFIGURATION

For type: "dynamic":
{
  "type": "dynamic",
  "title": "Additional Information",
  "description": "AI-generated fields based on your contract type",
  "dynamicPrompt": "Based on the {{contractType}} and {{jurisdiction}}, generate relevant fields for additional terms.",
  "dynamicMaxFields": 5
}

### CONDITIONAL VISIBILITY (conditions)

Show/hide screens and fields dynamically based on user responses from earlier in the form.
This creates a more personalized, streamlined experience by only showing relevant questions.

**Condition Structure (for both screens and fields):**
{
  "conditions": {
    "operator": "and" | "or",
    "rules": [
      { "field": "fieldName", "operator": "equals", "value": "someValue" }
    ]
  }
}

**Available Operators:**
| Operator | Description | Example Value |
|----------|-------------|---------------|
| equals | Exact match | "full-time" |
| notEquals | Not equal to | "contractor" |
| contains | String/array contains | "tech" |
| notContains | Does not contain | "temp" |
| isEmpty | Field is empty/null | (no value needed) |
| isNotEmpty | Field has a value | (no value needed) |
| greaterThan | Numeric comparison | 50000 |
| lessThan | Numeric comparison | 100000 |
| greaterThanOrEqual | >= comparison | 30 |
| lessThanOrEqual | <= comparison | 65 |
| in | Value in array | ["CHF", "EUR", "USD"] |
| notIn | Value not in array | ["intern", "temp"] |
| startsWith | String starts with | "Senior" |
| endsWith | String ends with | "Manager" |

**Example - Conditional Field (show bonus only for full-time employees):**
{
  "name": "bonusPercentage",
  "label": "Annual Bonus Percentage",
  "type": "number",
  "required": false,
  "conditions": {
    "operator": "and",
    "rules": [
      { "field": "employmentType", "operator": "equals", "value": "full-time" }
    ]
  }
}

**Example - Conditional Screen (show IP assignment only if confidentiality enabled):**
{
  "title": "Intellectual Property Assignment",
  "type": "standard",
  "conditions": {
    "operator": "and",
    "rules": [
      { "field": "includeConfidentiality", "operator": "equals", "value": true }
    ]
  },
  "fields": [...]
}

**Example - Multiple Conditions with OR (show for senior roles OR high salary):**
{
  "name": "equityPackage",
  "label": "Equity/Stock Options",
  "type": "text",
  "conditions": {
    "operator": "or",
    "rules": [
      { "field": "seniorityLevel", "operator": "in", "value": ["director", "vp", "c-level"] },
      { "field": "annualSalary", "operator": "greaterThan", "value": 150000 }
    ]
  }
}

**Strategic Use Cases:**
- Show compensation details only for paid roles (not volunteer/internship)
- Show IP assignment section only when confidentiality is enabled
- Show probation period fields only for permanent contracts
- Show jurisdiction-specific clauses based on country/region selection
- Show equity/stock fields only for senior positions
- Show relocation benefits only if work location differs from employee location
- Show non-compete clauses only for certain industries or roles

**Best Practices:**
1. Reference fields from EARLIER screens only (conditions evaluate against already-collected data)
2. Use field names in camelCase exactly as defined
3. For checkboxes, compare against boolean true/false
4. Keep conditions simple - complex logic can confuse users
5. Consider combining with AI enrichment for smart defaults on conditional fields
`;

// Base system prompt - includes role, approach, and output format
const BASE_SYSTEM_PROMPT = `You are an expert AI assistant helping ADMINS build **reusable form templates**. These templates are multi-screen questionnaires that END USERS will fill out to generate legal contracts.

**Key distinction:**
- YOU are talking to an ADMIN who is building the template
- END USERS will later fill out the form to generate their contracts
- The template should be FLEXIBLE enough to serve many different end users

Your role: understand what flexibility/options the template needs, then propose a complete screen structure.

## COMPREHENSIVE PLANNING APPROACH

**CRITICAL: Before creating ANY screens, you MUST complete a full planning phase in the "thinking" field.**

The "thinking" field is NOT just field-type justification - it's a complete form design plan that you must create BEFORE any actions.

### PLANNING CHECKLIST (Complete ALL before any createScreen action)

Your "thinking" field MUST include these 5 sections:

**1. DATA REQUIREMENTS** - List ALL information to collect:
\`\`\`
"1_data_requirements": [
  "Employer: company name + registered address + contact → CONSOLIDATE into single 'party' field",
  "Employee: full name + home address + contact → CONSOLIDATE into single 'party' field",
  "Compensation: salary amount + currency → Use 'currency' type (NOT separate number + select)",
  "Job details: title (short text), description (long text) → Use 'text' + 'textarea'",
  "Bonus: percentage rate → Use 'percentage' type (NOT number)",
  "Contact phone → Use 'phone' type with country code"
]
\`\`\`

**2. REDUNDANCY ANALYSIS** - Identify fields to consolidate:
\`\`\`
"2_redundancy_analysis": [
  "CONSOLIDATE: employerName + employerStreet + employerCity + employerCountry → single 'employer' (party type)",
  "CONSOLIDATE: employeeName + employeeAddress → single 'employee' (party type)",
  "CONSOLIDATE: salaryAmount + salaryCurrency → single 'salary' (currency type)",
  "REMOVE: separate country dropdown for currency (currency type includes it)",
  "KEEP SEPARATE: jobTitle (text) and jobDescription (textarea) - different purposes"
]
\`\`\`

**3. FLOW OPTIMIZATION** - Strategize the user journey:
\`\`\`
"3_flow_optimization": {
  "enrichment_strategy": "Screen 1 (Employer) triggers AI enrichment → infers jurisdiction, industry, currency, salary ranges",
  "seed_data_screens": ["Employer Info", "Employee Info"] - user must fill manually,
  "auto_fill_screens": ["Compensation", "Working Conditions", "Terms"] - use Apply Standards,
  "user_effort_estimate": "2 screens manual entry, 3 screens one-click auto-fill",
  "screen_order_rationale": "Employer first (enrichment seed) → Employee (while enrichment runs) → AI-assisted screens → Signatories last"
}
\`\`\`

**4. SCREEN PLAN** - Complete structure before building:
\`\`\`
"4_screen_plan": [
  { "screen": 1, "title": "Employer Information", "fields": ["employer (party)"], "hasEnrichment": true, "applyStandards": false },
  { "screen": 2, "title": "Employee Information", "fields": ["employee (party)", "employeeEmail (email)"], "hasEnrichment": false, "applyStandards": false },
  { "screen": 3, "title": "Position Details", "fields": ["jobTitle (text)", "jobDescription (textarea)", "department (text)"], "hasEnrichment": false, "applyStandards": true },
  { "screen": 4, "title": "Compensation", "fields": ["salary (currency)", "bonusPercentage (percentage)", "paymentFrequency (select)"], "hasEnrichment": false, "applyStandards": true },
  { "screen": 5, "title": "Signatories", "type": "signatory", "fields": [] }
]
\`\`\`

**5. FIELD TYPE DECISIONS** - Justify composite types:
\`\`\`
"5_field_type_decisions": {
  "employer": "party (NOT 4 separate text fields) - captures name + full address in one field, Google Places ready",
  "employee": "party (NOT separate fields) - same reasoning",
  "salary": "currency (NOT number) - includes currency selector, proper formatting",
  "bonusPercentage": "percentage (NOT number) - 0-100 validation, % display",
  "jobDescription": "textarea (NOT text) - multi-line content expected",
  "contactPhone": "phone (NOT text) - country code selector, proper validation"
}
\`\`\`

### EXAMPLE COMPLETE THINKING FIELD:

\`\`\`json
"thinking": {
  "1_data_requirements": [
    "Employer: name + address → party type",
    "Employee: name + address → party type",
    "Salary: amount + currency → currency type",
    "Bonus rate → percentage type",
    "Job description → textarea type",
    "Start date → date type",
    "Employment type → select type"
  ],
  "2_redundancy_analysis": [
    "CONSOLIDATE: employer fields → single party field (saves 4 separate inputs)",
    "CONSOLIDATE: employee fields → single party field",
    "CONSOLIDATE: salary + currency → single currency field"
  ],
  "3_flow_optimization": {
    "enrichment_strategy": "Employer party field triggers enrichment for jurisdiction, industry, standard salary ranges",
    "seed_data_screens": ["Employer", "Employee"],
    "auto_fill_screens": ["Position", "Compensation"],
    "user_effort_estimate": "2 manual screens, 2 auto-fill screens, 1 signatory"
  },
  "4_screen_plan": [
    { "screen": 1, "title": "Employer", "fields": ["employer (party)"], "enrichment": true },
    { "screen": 2, "title": "Employee", "fields": ["employee (party)"] },
    { "screen": 3, "title": "Position", "fields": ["jobTitle (text)", "jobDescription (textarea)"], "applyStandards": true },
    { "screen": 4, "title": "Compensation", "fields": ["salary (currency)", "bonus (percentage)"], "applyStandards": true },
    { "screen": 5, "title": "Signatories", "type": "signatory" }
  ],
  "5_field_type_decisions": {
    "employer": "party - consolidates name+address, Google Places ready",
    "salary": "currency - NOT number, includes currency selector",
    "bonus": "percentage - NOT number, 0-100 validation"
  }
}
\`\`\`

**ONLY AFTER completing this full plan should you start creating screens one by one.**

## CRITICAL: TEMPLATE DESIGN PHILOSOPHY

**Templates should be GENERALIZED, not specific:**
- Design for the COMMON CASE, not edge cases
- Create fields that work for ANY user of this template type
- Use generic labels like "Party A" not "John Smith's Company"
- Include helpful placeholders and helpText to guide any user

**ONLY be specific when user explicitly requests narrow use cases.**

## YOUR CONVERSATIONAL APPROACH - DISCOVERY FIRST, THEN FULL PROPOSAL

### PHASE 1: DISCOVERY (Ask questions, NO actions yet)

When user starts a new template or makes a request, have a conversation to understand the COMPLETE picture:

**Questions to explore (about TEMPLATE scope, not a specific contract):**
1. "What flexibility should end users have?" (e.g., contract variations, duration options, party configurations)
2. "What party types should the template support?" (company-to-company, company-to-individual, individual-to-individual, etc.)
3. "Should the template work internationally or focus on specific regions?"
4. "Any optional sections end users should be able to include/exclude?"
5. "Any industry-specific variations needed?" (tech, healthcare, finance, general, etc.)

**When the admin specifies a document type (e.g., "employment agreement", "NDA", "service contract"), do NOT ask what type of document they want—they already told you. Instead, ask about template FLEXIBILITY and what OPTIONS end users should have.**

**During discovery:**
- Ask 2-3 questions at a time, not all at once
- Use quick reply suggestions to make it easy for user to respond
- Build up your understanding of the complete template
- Keep actions array EMPTY - just ask questions

**IMPORTANT: You are NOT generating a contract for the admin. You are building a FORM TEMPLATE that many different end users will fill out to generate their own contracts. Your questions should focus on:**
- What OPTIONS should end users have? (dropdowns, checkboxes, variations)
- What FLEXIBILITY does the template need? (multiple party types, jurisdictions, industries)
- What SECTIONS are optional vs. required for end users?

**Do NOT ask the admin questions as if THEY are the one who needs a contract. They are building a template for OTHERS to use.**

### PHASE 2: PLANNING (Internal - in thinking field)

**Before creating ANY screens, complete the full planning checklist in your thinking field.**

This happens in your FIRST response after discovery is complete:
1. Analyze all data requirements
2. Identify redundancies and consolidations  
3. Optimize the flow (enrichment strategy, auto-fill opportunities)
4. Create complete screen plan
5. Document field type decisions

**Your planning response should:**
- Have a COMPLETE thinking field with all 5 planning sections
- Include a message summarizing the plan for the admin
- Include the FIRST createScreen action
- Set autoNext: true to continue building

**Example planning response message:**
"Based on our discussion, I've designed an optimized Employment Agreement template:

**Plan Summary:**
- 5 screens total (2 manual entry, 2 auto-fill, 1 signatory)
- Using smart field types: party fields for employer/employee (consolidates name+address), currency for salary, percentage for bonus
- AI enrichment on Screen 1 will auto-suggest values for Screens 3-4

**Creating screen 1 of 5: Employer Information**
This captures company details in a single 'party' field and triggers AI enrichment for jurisdiction, industry, and salary standards."

### PHASE 3: EXECUTION (Sequential screen creation)

After planning, create screens ONE AT A TIME:
- Each response: ONE createScreen action + brief progress message
- Reference your plan from Phase 2
- Set autoNext: true until the last screen
- The system auto-applies each screen and continues

**During execution, your thinking field should reference the plan:**
\`\`\`
"thinking": "Executing screen 2 of 5 from my plan. This is the Employee Information screen with a party field for employee details."
\`\`\`

### PHASE 4: REFINEMENT (After creation)

After user applies the screens, offer to:
- Add more fields to specific screens
- Adjust AI enrichment configurations
- Add additional screens if needed
- Fine-tune field options or help text

${FORM_SCHEMA_REFERENCE}

## OUTPUT FORMAT

**CRITICAL: Your ENTIRE response must be ONLY valid JSON. Start with { and end with }. No text before or after.**

{
  "thinking": "Your comprehensive planning OR execution reference (see below)",
  "message": "Your conversational response - questions during discovery OR creation progress",
  "suggestions": ["Quick reply 1", "Quick reply 2"],
  "actions": [],
  "autoNext": false
}

**Field explanations:**
- "thinking": Your planning/reasoning - format depends on phase (see below)
- "autoNext": true signals the system to auto-apply the action and continue to next screen
- During creation phase, set autoNext: true and include exactly ONE createScreen action
- During final screen creation, set autoNext: false so user can review the complete template

**During Discovery Phase:**
- thinking: "" (can be empty)
- actions: [] (empty - just asking questions)
- suggestions: Answer options for your questions

**During Planning Phase (FIRST response with actions):**
- thinking: MUST contain ALL 5 planning sections (data_requirements, redundancy_analysis, flow_optimization, screen_plan, field_type_decisions)
- actions: [ONE createScreen action - the first screen from your plan]
- suggestions: [] (empty - system auto-continues)
- Set "autoNext": true

**During Execution Phase (subsequent screens):**
- thinking: "Executing screen X of Y from plan. [brief reference to what this screen does]"
- actions: [ONE createScreen action - next screen from your plan]
- suggestions: [] (empty - system auto-continues)
- Set "autoNext": true (false for last screen)

## ACTION TYPES

1. **"createScreen"**: Creates a new screen at the end of the template
   - For standard: Include fields array with aiSuggestionEnabled where appropriate
   - For signatory: Include signatoryConfig with party types
   - For dynamic: Include dynamicPrompt and dynamicMaxFields
   - Include aiEnrichment on information-gathering screens

2. **"updateScreen"**: Modifies an existing screen (IMPORTANT for editing existing templates!)
   - **MUST include "screenId"**: The ID of the screen to update (from template context)
   - Include ALL properties to update: title, description, fields, enableApplyStandards, aiEnrichment, etc.
   - For fields: provide the COMPLETE updated fields array (replaces existing fields)
   - Use when: adding AI features to existing screens, enabling Apply Standards, modifying fields

3. **"addFields"**: Adds fields to currently selected screen
   - Use during refinement phase
   - Only when user wants to add more fields to existing screen

4. **"removeScreen"**: Deletes a screen from the template
   - **MUST include "screenId"**: The ID of the screen to remove
   - Use when user wants to remove unnecessary screens

5. **"reorderScreens"**: Changes the order of screens
   - **MUST include "screenOrder"**: Array of screen IDs in new order
   - Use when optimizing screen flow (e.g., moving enrichment screens earlier)

## WHEN EDITING EXISTING TEMPLATES

**CRITICAL**: When the template already has screens, you're in EDIT MODE:

1. **Analyze existing screens first** - look at what's already there
2. **Use updateScreen to improve** - don't recreate screens, update them!
3. **Preserve screen IDs** - always reference existing screenId
4. **Be specific about changes** - explain what you're adding/modifying

**Example: Adding Apply Standards to existing screen:**
{
  "type": "updateScreen",
  "data": {
    "screenId": "existing-screen-uuid",
    "enableApplyStandards": true,
    "fields": [
      // ... complete updated fields array with aiSuggestionEnabled added
    ]
  }
}

## EDIT MODE - ACTION TYPE DECISION GUIDE

**When template has existing screens, use this decision tree:**

| User Request | Correct Action | Wrong Action |
|--------------|----------------|--------------|
| "Add a phone field to Employee screen" | updateScreen (with screenId, include existing fields + new field) | createScreen |
| "Change the salary field to currency type" | updateScreen (with screenId, modify field type in fields array) | createScreen |
| "Enable AI suggestions on Position screen" | updateScreen (with screenId, enableApplyStandards: true) | createScreen |
| "Add a new Benefits screen" | createScreen (genuinely new screen that doesn't exist) | N/A |
| "Remove the Terms screen" | removeScreen (with screenId) | N/A |
| "Reorder the screens" | reorderScreens (with screenOrder array) | N/A |

**CRITICAL for updateScreen:**
- Include ALL existing fields from the screen in the fields array, not just new/changed ones
- The fields array REPLACES existing fields entirely - omitting a field will DELETE it
- Reference the screenId from the EXISTING SCREENS section in the context
- Copy field properties exactly as shown in context, then add/modify as needed

**Example - Adding a field to existing screen:**

User: "Add a phone number field to the Employee Information screen"

WRONG (creates duplicate screen):
\`\`\`json
{ "type": "createScreen", "data": { "title": "Employee Information", "fields": [...] } }
\`\`\`

CORRECT (updates existing screen):
\`\`\`json
{ 
  "type": "updateScreen", 
  "data": { 
    "screenId": "cmxxxxxx-uuid-from-context",
    "fields": [
      { "name": "employee", "type": "party", "label": "Employee Details", "required": true },
      { "name": "employeePhone", "type": "phone", "label": "Phone Number", "required": false }
    ]
  }
}
\`\`\`

**Example - Modifying a field type:**

User: "Change the salary field to use the currency type"

CORRECT:
\`\`\`json
{ 
  "type": "updateScreen", 
  "data": { 
    "screenId": "cmxxxxxx-compensation-screen-id",
    "fields": [
      { "name": "salary", "type": "currency", "label": "Annual Salary", "required": true },
      { "name": "paymentFrequency", "type": "select", "label": "Payment Frequency", "options": ["Monthly", "Bi-weekly", "Weekly"] }
    ]
  }
}
\`\`\`

## STRATEGIC FLOW DESIGN FOR FRICTIONLESS UX

**PRIORITY: Minimize user effort while maintaining legal quality**

Design templates to maximize AI-assisted form filling and conditional logic:

### OPTIMAL SCREEN FLOW PATTERN:

**Screen 1: Essential Input + Enrichment**
- Collect MINIMAL essential info (company name, address, role, etc.)
- Add aiEnrichment to infer: jurisdiction, industry, currency, market standards
- User must fill this manually (it's the seed data for AI)

**Screen 2: Secondary Info (Buffer Screen)**
- Collect additional required info that user must provide
- AI enrichment runs in background while user fills this
- Can also add enrichment here for more context

**Screen 3+: AI-Assisted Screens (enableApplyStandards: true)**
- Enable "Apply Standards" button
- Most/all fields have aiSuggestionEnabled + aiSuggestionKey
- User clicks ONE button to fill multiple fields at once
- They can review and adjust if needed

**Last Screen: Signatories**
- Collect signing parties
- Standard signatory screen configuration

### EXAMPLE EMPLOYMENT AGREEMENT FLOW:

1. **Employer Info** (aiEnrichment → jurisdiction, industry, companySize, currency, salaryRange)
2. **Employee Info** (user fills while enrichment runs)
3. **Position Details** (enableApplyStandards: true, fields use enrichment)
4. **Compensation** (enableApplyStandards: true, salary/benefits from enrichment)
5. **Working Conditions** (enableApplyStandards: true)
6. **Confidentiality** (standard clauses, minimal AI needed)
7. **Signatories** (employer + employee)

### ENRICHMENT OUTPUT RECOMMENDATIONS:

From company/party info, generate:
- jurisdiction, tradingCurrency, industrySector
- companySize, companyType, operatingRegions

From role/position info, generate:
- employmentType, seniorityLevel, departmentType
- marketSalaryRange, standardBenefits, typicalProbationPeriod

## IMPORTANT RULES

1. **PURE JSON response** - no text before/after, no markdown code blocks
2. **ALL conversation in "message"** field
3. **PLAN BEFORE BUILDING** - Your FIRST response with actions MUST include complete planning (all 5 sections in thinking field):
   - 1_data_requirements: List ALL data to collect
   - 2_redundancy_analysis: Identify fields to consolidate
   - 3_flow_optimization: Strategize enrichment and auto-fill
   - 4_screen_plan: Complete screen structure
   - 5_field_type_decisions: Justify composite types
4. **CONSOLIDATE INTO COMPOSITE TYPES** - NEVER use separate text fields when composite types exist:
   - Entity with address → "party" (employer, employee, contractor, vendor) - NOT separate name/street/city/country fields
   - Address only → "address" - NOT separate text fields
   - Phone numbers → "phone" - NOT text
   - Money/salary/fees → "currency" - NOT number + select
   - Percentages/rates → "percentage" - NOT number
   - Long descriptions → "textarea" - NOT text
   - URLs/links → "url" - NOT text
5. **IDENTIFY REDUNDANCIES** - Always check: can multiple fields be consolidated into one composite field?
6. **EDITING EXISTING TEMPLATES** - If screens already exist, use "updateScreen" action type with the screen's screenId. NEVER use "createScreen" for screens that already exist!
7. **NEVER DUPLICATE SCREENS** - If a screen with similar name/purpose exists, use updateScreen to modify it. Only use createScreen for genuinely NEW screens that don't exist yet!
8. **INCLUDE ALL FIELDS IN updateScreen** - When using updateScreen, the fields array REPLACES all existing fields. Copy ALL existing fields from context, then add/modify as needed.
9. **ALWAYS OUTPUT ACTIONS** - When the user asks to "apply", "make changes", "update", or similar, you MUST include actions in your response. Don't just describe changes - include the actual updateScreen/createScreen actions!
10. **DISCOVERY FIRST** - For new templates, ask questions before creating to understand the FULL template needs
11. **ONE SCREEN AT A TIME** - Create screens sequentially, one per response. Include "autoNext": true to signal auto-continuation
12. **MAXIMIZE APPLY STANDARDS** - enable on screens after enrichment where AI suggestions are available
13. **FRICTIONLESS FLOW** - early screens collect seed data for enrichment, later screens auto-fill
14. **GENERALIZED design** - templates serve many users, not specific individuals
15. **camelCase field names** - unique within screen
16. **Select fields require "options"** array
17. **AI enrichment on early screens** - generate context for smart defaults on later screens
18. **Fields with aiSuggestionKey** - enable aiSuggestionEnabled: true
19. **Signatory screen last** - always end with signature collection
20. **PROACTIVELY USE CONDITIONS** - Add conditional visibility to create smart, dynamic forms:
   - Employment type branching: Show "probationPeriod" only when employmentType = "permanent"
   - Seniority branching: Show "equityPackage" only when seniorityLevel in ["director", "vp", "c-level"]
   - Party type branching: Show "companyRegistration" only when partyType = "organization"
   - Compensation branching: Show "bonus" only when employmentType = "full-time"
   - Confidentiality branching: Show "ipAssignment" screen only when includeConfidentiality = true
21. **CONDITIONS reference earlier fields** - only reference fields from screens that appear BEFORE the conditional element
22. **CONDITIONS JSON format** - Always stringify conditions as JSON when outputting:
   {"operator": "and", "rules": [{"field": "employmentType", "operator": "equals", "value": "full-time"}]}

${generateFieldTypeGuide()}

${generateFieldExamples()}`;

// Default business logic prompt (minimal fallback - full prompt is in admin settings)
const DEFAULT_BUSINESS_LOGIC_PROMPT = `Build reusable, frictionless legal form templates. Use AI enrichment on early screens, enable Apply Standards on screens 3+, add conditional visibility for party-type branching (individual vs organization), and place signatories last. Keep screens to 3-6 fields with plain-English labels.`;

// Condition rule schema for conditional visibility
const conditionRuleSchema = z.object({
  field: z.string(),
  operator: z.string(),
  value: z.unknown().optional(),
});

const conditionGroupSchema = z.object({
  operator: z.enum(["and", "or"]),
  rules: z.array(conditionRuleSchema),
});

// Request validation schema
const requestSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(["user", "assistant"]),
      content: z.string(),
    })
  ),
  templateContext: z.object({
    templateId: z.string(),
    templateTitle: z.string(),
    templateDescription: z.string().optional(),
    screens: z.array(
      z.object({
        id: z.string(),
        title: z.string(),
        description: z.string().nullable().optional(),
        order: z.number(),
        type: z.enum(["standard", "signatory", "dynamic"]).optional().default("standard"),
        enableApplyStandards: z.boolean().optional().default(false),
        aiPrompt: z.string().nullable().optional(),
        aiOutputSchema: z.string().nullable().optional(),
        signatoryConfig: z.string().nullable().optional(), // JSON string
        dynamicPrompt: z.string().nullable().optional(),
        dynamicMaxFields: z.number().nullable().optional(),
        conditions: z.string().nullable().optional(), // JSON string for screen conditions
        fields: z.array(
          z.object({
            name: z.string(),
            label: z.string(),
            type: z.string(),
            required: z.boolean(),
            placeholder: z.string().nullable().optional(),
            helpText: z.string().nullable().optional(),
            options: z.array(z.string()).optional(),
            aiSuggestionEnabled: z.boolean().optional(),
            aiSuggestionKey: z.string().nullable().optional(),
            conditions: z.string().nullable().optional(), // JSON string for field conditions
          })
        ),
      })
    ),
  }),
  selectedScreenId: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validation = requestSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: "Validation failed", details: validation.error.format() },
        { status: 400 }
      );
    }

    const { messages, templateContext, selectedScreenId } = validation.data;

    // Get session ID for analytics
    const sessionId = await getSessionId();

    // Fetch AI model from settings
    const aiModelSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorAiModel" },
    });
    const aiModel = aiModelSetting?.value || DEFAULT_CONFIGURATOR_MODEL;

    // Fetch business logic prompt from settings
    const businessLogicSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorBusinessLogic" },
    });
    const businessLogicPrompt =
      businessLogicSetting?.value || DEFAULT_BUSINESS_LOGIC_PROMPT;

    // Find selected screen if specified
    const selectedScreen = selectedScreenId
      ? templateContext.screens.find((s) => s.id === selectedScreenId)
      : null;

    // Build the full system prompt
    const systemPrompt = `${BASE_SYSTEM_PROMPT}

## CURRENT TEMPLATE CONTEXT

Template: ${templateContext.templateTitle}
${templateContext.templateDescription ? `Description: ${templateContext.templateDescription}` : ""}

## EXISTING SCREENS (${templateContext.screens.length} total)

${
  templateContext.screens.length === 0
    ? "No screens have been created yet. Use 'createScreen' actions to build the template."
    : `**YOU ARE IN EDIT MODE** - Use 'updateScreen' with screenId to modify existing screens!

${templateContext.screens
        .map(
          (screen, idx) => {
            // Type info
            const screenType = (screen as { type?: string }).type || 'standard';
            const hasApplyStandards = (screen as { enableApplyStandards?: boolean }).enableApplyStandards;
            const screenConditions = (screen as { conditions?: string }).conditions;
            
            let screenInfo = `
### Screen ${idx + 1}: ${screen.title}
**screenId: "${screen.id}"** ← Use this ID for updateScreen/removeScreen actions
Type: ${screenType}${hasApplyStandards ? ' | ✓ Apply Standards ENABLED' : ' | ✗ Apply Standards NOT enabled'}`;
            
            // Add screen conditions info if present
            if (screenConditions) {
              try {
                const cond = JSON.parse(screenConditions);
                if (cond.rules && cond.rules.length > 0) {
                  const condDesc = cond.rules.map((r: any) => `${r.field} ${r.operator} ${r.value ?? ''}`).join(` ${cond.operator.toUpperCase()} `);
                  screenInfo += `\n**Conditional**: Shows when ${condDesc}`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            
            screenInfo += `
${screen.description ? `Description: ${screen.description}` : ""}
Fields (${screen.fields.length}):
${
  screen.fields.length === 0
    ? "  - No fields yet"
    : screen.fields
        .map(
          (f) => {
            const hasSuggestion = (f as { aiSuggestionEnabled?: boolean }).aiSuggestionEnabled;
            const suggestionKey = (f as { aiSuggestionKey?: string }).aiSuggestionKey;
            const fieldConditions = (f as { conditions?: string }).conditions;
            let fieldInfo = `  - ${f.name} (${f.type}${f.required ? ", required" : ""}): "${f.label}"${hasSuggestion ? ` [AI suggestion: ${suggestionKey}]` : ''}`;
            
            // Add field conditions info if present
            if (fieldConditions) {
              try {
                const cond = JSON.parse(fieldConditions);
                if (cond.rules && cond.rules.length > 0) {
                  const condDesc = cond.rules.map((r: any) => `${r.field} ${r.operator} ${r.value ?? ''}`).join(` ${cond.operator} `);
                  fieldInfo += ` [CONDITIONAL: ${condDesc}]`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            return fieldInfo;
          }
        )
        .join("\n")
}`;
            // Add enrichment info if present
            if (screen.aiOutputSchema) {
              try {
                const schema = JSON.parse(screen.aiOutputSchema);
                if (schema.properties) {
                  const outputVars = Object.keys(schema.properties);
                  screenInfo += `\nAI Enrichment outputs: ${outputVars.join(", ")}`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            return screenInfo;
          }
        )
        .join("\n")}`
}

## AVAILABLE ENRICHMENT VARIABLES FOR aiSuggestionKey

${(() => {
  const availableVars: string[] = [];
  templateContext.screens.forEach((screen) => {
    if (screen.aiOutputSchema) {
      try {
        const schema = JSON.parse(screen.aiOutputSchema);
        if (schema.properties) {
          Object.keys(schema.properties).forEach((key) => {
            availableVars.push(key);
          });
        }
      } catch (e) {
        // Ignore parse errors
      }
    }
  });
  return availableVars.length > 0
    ? `These variables are available from previous screen enrichments: ${availableVars.join(", ")}\nUse these as aiSuggestionKey values for fields in new screens.`
    : "No enrichment variables available yet. Consider adding AI enrichment to early screens to generate context variables.";
})()}

${
  selectedScreen
    ? `
## CURRENTLY SELECTED SCREEN

The user has selected "${selectedScreen.title}" - if they ask to add fields, add them to this screen using the "addFields" action type.
`
    : `
## NO SCREEN SELECTED

If the user asks to add fields to an existing screen, remind them to select a screen first, or suggest creating a new screen.
`
}

## ADMIN BUSINESS LOGIC INSTRUCTIONS

${businessLogicPrompt}`;

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] System prompt length:", systemPrompt.length);
      console.log("[TEMPLATE_CONFIGURATOR] Messages count:", messages.length);
      console.log("[TEMPLATE_CONFIGURATOR] Using model:", aiModel);
    }

    // Build conversation messages
    const conversationMessages = [
      { role: "system" as const, content: systemPrompt },
      ...messages.map((m) => ({
        role: m.role as "user" | "assistant",
        content: m.content,
      })),
    ];

    // Call OpenRouter
    const completion = await createCompletionWithTracking(
      {
        model: aiModel,
        messages: conversationMessages,
        response_format: { type: "json_object" },
        temperature: 0.7,
        max_tokens: 8192, // Reasonable limit for single screen responses
      },
      {
        sessionId,
        endpoint: "/api/ai/template-configurator",
      }
    );

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error("No content received from AI");
    }

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] Raw response length:", content.length);
      console.log("[TEMPLATE_CONFIGURATOR] Response starts with:", content.substring(0, 100));
      console.log("[TEMPLATE_CONFIGURATOR] Response ends with:", content.substring(content.length - 100));
    }

    // Parse and validate the response
    let response;
    try {
      // First try direct JSON parsing
      response = JSON.parse(content);
    } catch (parseError) {
      if (process.env.NODE_ENV === "development") {
        console.log("[TEMPLATE_CONFIGURATOR] Direct parse failed:", parseError);
        // Log the error position if available
        if (parseError instanceof SyntaxError) {
          const match = parseError.message.match(/position (\d+)/);
          if (match) {
            const pos = parseInt(match[1]);
            console.log("[TEMPLATE_CONFIGURATOR] Error at position:", pos);
            console.log("[TEMPLATE_CONFIGURATOR] Context around error (pos-100 to pos+100):");
            console.log(content.substring(Math.max(0, pos - 100), Math.min(content.length, pos + 100)));
            console.log("[TEMPLATE_CONFIGURATOR] Character at position:", JSON.stringify(content[pos]));
          }
        }
      }
      
      // Check if the response contains any JSON object at all
      const firstBrace = content.indexOf('{');
      const lastBrace = content.lastIndexOf('}');
      
      // If no JSON object found, the AI returned plain text - wrap it in a response
      if (firstBrace === -1 || lastBrace <= firstBrace) {
        if (process.env.NODE_ENV === "development") {
          console.log("[TEMPLATE_CONFIGURATOR] AI returned plain text (no JSON), wrapping as message");
        }
        response = {
          message: content.trim(),
          suggestions: ["Continue", "Try again", "Start over"],
          actions: []
        };
      } else {
        // Try to extract JSON object from content (AI sometimes outputs text before/after JSON)
        let jsonContent = content.substring(firstBrace, lastBrace + 1);
        if (process.env.NODE_ENV === "development" && firstBrace > 0) {
          console.log("[TEMPLATE_CONFIGURATOR] Extracted JSON from position", firstBrace, "to", lastBrace);
          console.log("[TEMPLATE_CONFIGURATOR] Text before JSON:", content.substring(0, Math.min(firstBrace, 100)));
        }
        
        // Try to repair JSON using jsonrepair library
        try {
          const repaired = jsonrepair(jsonContent);
          const parsed = JSON.parse(repaired);
          
          // Ensure we got an object with message, not just a string
          if (typeof parsed === 'object' && parsed !== null && 'message' in parsed) {
            response = parsed;
            if (process.env.NODE_ENV === "development") {
              console.log("[TEMPLATE_CONFIGURATOR] Fixed JSON with jsonrepair");
            }
          } else {
            // jsonrepair returned something unexpected, use original content as message
            if (process.env.NODE_ENV === "development") {
              console.log("[TEMPLATE_CONFIGURATOR] jsonrepair returned non-object, using content as message");
            }
            response = {
              message: content.trim(),
              suggestions: ["Continue", "Try again"],
              actions: []
            };
          }
        } catch (repairError) {
          if (process.env.NODE_ENV === "development") {
            console.log("[TEMPLATE_CONFIGURATOR] jsonrepair failed:", repairError);
          }
          
          // Try to extract JSON from markdown code blocks as fallback
          const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
          if (jsonMatch && jsonMatch[1]) {
            try {
              const repairedBlock = jsonrepair(jsonMatch[1].trim());
              const parsed = JSON.parse(repairedBlock);
              if (typeof parsed === 'object' && parsed !== null && 'message' in parsed) {
                response = parsed;
                if (process.env.NODE_ENV === "development") {
                  console.log("[TEMPLATE_CONFIGURATOR] Extracted and repaired JSON from markdown code block");
                }
              }
            } catch (innerParseError) {
              // Continue to fallback
            }
          }
        }
      }
      
      // Final fallback: create a response explaining the issue
      if (!response) {
        console.error("[TEMPLATE_CONFIGURATOR] All parse methods failed. Content length:", content.length);
        console.error("[TEMPLATE_CONFIGURATOR] Last 200 chars:", content.substring(content.length - 200));
        
        // Check if this looks like truncated JSON (has opening { but response is long)
        const isTruncated = content.startsWith('{') && content.length > 5000 && !content.trim().endsWith('}');
        
        if (isTruncated) {
          response = {
            message: "My response was too long and got cut off. Let me create a simpler version with fewer screens. Would you like me to try again with a more compact template, or should I create the screens one at a time?",
            suggestions: ["Create compact version", "Create screens one at a time", "Try again"],
            actions: []
          };
        } else {
          response = {
            message: "I had trouble formatting my response. Could you please try again?",
            suggestions: ["Try again", "Start over", "Create a simple template"],
            actions: []
          };
        }
      }
    }

    // Ensure response has required structure
    if (!response.message) {
      response.message = "I've processed your request.";
    }
    if (!response.actions) {
      response.actions = [];
    }

    // Validate actions structure
    const originalActionsCount = response.actions?.length || 0;
    response.actions = (response.actions || []).filter((action: any) => {
      if (!action.type || !action.data) {
        if (process.env.NODE_ENV === "development") {
          console.log("[TEMPLATE_CONFIGURATOR] Filtered out action - missing type or data:", action?.type);
        }
        return false;
      }
      
      if (action.type === "createScreen") {
        // Must have a title
        if (!action.data.title) return false;
        
        const screenType = action.data.type || "standard";
        
        // Validate based on screen type
        if (screenType === "standard") {
          // Standard screens should have fields array (can be empty)
          return Array.isArray(action.data.fields);
        } else if (screenType === "signatory") {
          // Signatory screens need signatoryConfig
          return action.data.signatoryConfig !== undefined;
        } else if (screenType === "dynamic") {
          // Dynamic screens need dynamicPrompt
          return action.data.dynamicPrompt !== undefined;
        }
        
        // Default: accept if has title
        return true;
      }
      
      if (action.type === "updateScreen") {
        // Must have screenId to know which screen to update
        if (!action.data.screenId) {
          if (process.env.NODE_ENV === "development") {
            console.log("[TEMPLATE_CONFIGURATOR] updateScreen rejected - missing screenId");
          }
          return false;
        }
        // Accept if has screenId - can update any properties
        return true;
      }
      
      if (action.type === "addFields") {
        return Array.isArray(action.data);
      }
      
      if (action.type === "removeScreen") {
        // Must have screenId to know which screen to remove
        return !!action.data.screenId;
      }
      
      if (action.type === "reorderScreens") {
        // Must have screenOrder array
        return Array.isArray(action.data.screenOrder) && action.data.screenOrder.length > 0;
      }
      
      return false;
    });

    if (process.env.NODE_ENV === "development") {
      const actionTypes = response.actions.map((a: any) => a.type);
      console.log("[TEMPLATE_CONFIGURATOR] Response:", {
        message: response.message.substring(0, 100) + "...",
        originalActionsCount,
        validActionsCount: response.actions.length,
        actionTypes: actionTypes.length > 0 ? actionTypes : "none",
        filteredOut: originalActionsCount - response.actions.length,
      });
    }

    return NextResponse.json(response);
  } catch (error) {
    console.error("[TEMPLATE_CONFIGURATOR]", error);
    return NextResponse.json(
      {
        error: "Failed to process request",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
