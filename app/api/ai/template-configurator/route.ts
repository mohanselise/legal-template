import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { jsonrepair } from "jsonrepair";
import { createCompletionWithTracking } from "@/lib/openrouter";
import { getSessionId } from "@/lib/analytics/session";
import { prisma } from "@/lib/db";

// Default model if not configured in settings
const DEFAULT_CONFIGURATOR_MODEL = "anthropic/claude-sonnet-4";

// ============================================================================
// DYNAMIC SCHEMA REFERENCE - This is the complete form builder capability
// ============================================================================

const FORM_SCHEMA_REFERENCE = `
## COMPLETE FORM BUILDER SCHEMA

You have access to a powerful form builder system. Here's everything you can create:

### SCREEN TYPES

1. **standard** (default): Regular form screen with custom fields
   - Most common type for collecting user input
   - Supports all field types and AI enrichment
   - Use for: Party info, contract terms, compensation details, etc.

2. **signatory**: Special screen for collecting signatory/party information
   - Pre-built UI for managing multiple signatories
   - Supports: name, email, title, phone, company, address
   - Modes: "deterministic" (fixed slots) or "dynamic" (user adds/removes)
   - Use for: Collecting parties who will sign the document

3. **dynamic**: AI-generated screen with fields created on-the-fly
   - Fields are generated by AI based on context from previous screens
   - Useful for conditional/context-dependent data collection
   - Requires: dynamicPrompt (AI instructions), dynamicMaxFields (limit)

### FIELD TYPES (for standard screens)

| Type | Description | Use Case |
|------|-------------|----------|
| text | Single-line text input | Names, titles, addresses, general text |
| email | Email with validation | Contact emails, notification addresses |
| date | Date picker | Start dates, end dates, deadlines |
| number | Numeric input | Salaries, amounts, quantities, percentages |
| checkbox | Boolean yes/no | Agreements, optional clauses, confirmations |
| select | Dropdown with options | Fixed choices (countries, currencies, types) |

### FIELD PROPERTIES

Required:
- name: camelCase identifier (unique within screen)
- label: Human-readable display label
- type: One of the field types above
- required: Boolean - whether field must be filled

Optional:
- placeholder: Hint text shown in empty input
- helpText: Explanation text below field (great for legal context)
- options: String array (REQUIRED for select type)
- aiSuggestionEnabled: Boolean - enable AI auto-fill from enrichment context
- aiSuggestionKey: String - key from previous screen's AI enrichment output

### SCREEN PROPERTIES

Required:
- title: Screen heading
- fields: Array of field objects (for standard type)

Optional:
- description: Helper text explaining the screen's purpose
- type: "standard" | "signatory" | "dynamic" (defaults to standard)
- aiEnrichment: Object with prompt and outputSchema (for AI context generation)
- enableApplyStandards: Boolean - enables one-click "Apply Standards" button for AI suggestions

For signatory screens:
- signatoryConfig: { mode, partyTypes, minSignatories, maxSignatories, collectFields, predefinedSignatories }

For dynamic screens:
- dynamicPrompt: AI instructions to generate fields
- dynamicMaxFields: Maximum fields to generate (default: 5)

### AI ENRICHMENT SYSTEM

The AI Enrichment system creates intelligent form auto-fill:

1. **Screen Enrichment Prompt**: Runs after screen completion
   - Reference fields with {{fieldName}} syntax
   - Analyzes user inputs to infer additional context (runs in background)

2. **Output Schema**: Defines context variables generated
   - JSON Schema format with properties and types
   - These become available for later screens' aiSuggestionKey

3. **Field AI Suggestions**: Auto-populate from enrichment
   - Set aiSuggestionEnabled: true
   - Set aiSuggestionKey: "propertyNameFromSchema"
   - User sees suggested value they can accept or modify

### APPLY STANDARDS FEATURE (KEY FOR FRICTIONLESS UX)

**enableApplyStandards: true** enables a one-click "Apply Standards" button on screens:
- When user reaches this screen, they see a prominent button
- One click fills ALL fields that have AI suggestions configured
- Dramatically reduces manual data entry

**STRATEGIC USE:**
- Enable on screens AFTER enrichment has run (Screen 3+)
- Only works if fields have aiSuggestionEnabled + aiSuggestionKey
- Perfect for: compensation screens, terms screens, condition screens

**Example screen with Apply Standards:**
{
  "title": "Compensation & Benefits",
  "enableApplyStandards": true,
  "fields": [
    { "name": "currency", "label": "Currency", "type": "select", "options": ["CHF", "EUR", "USD"], "aiSuggestionEnabled": true, "aiSuggestionKey": "tradingCurrency" },
    { "name": "annualSalary", "label": "Annual Salary", "type": "number", "aiSuggestionEnabled": true, "aiSuggestionKey": "marketSalaryRange" },
    { "name": "bonusPercentage", "label": "Bonus %", "type": "number", "aiSuggestionEnabled": true, "aiSuggestionKey": "standardBonusRate" }
  ]
}

### SIGNATORY SCREEN CONFIGURATION

For type: "signatory", use signatoryConfig:
{
  "mode": "dynamic", // or "deterministic" for fixed slots
  "partyTypes": [
    { "value": "employer", "label": "Employer", "description": "The hiring company" },
    { "value": "employee", "label": "Employee", "description": "The person being hired" }
  ],
  "minSignatories": 2,
  "maxSignatories": 10,
  "collectFields": {
    "name": true,      // Always required
    "email": true,     // Always required  
    "title": true,     // Job title/role
    "phone": false,    // Phone number
    "company": true,   // Company name
    "address": false   // Address
  },
  "predefinedSignatories": [] // For deterministic mode
}

### DYNAMIC SCREEN CONFIGURATION

For type: "dynamic":
{
  "type": "dynamic",
  "title": "Additional Information",
  "description": "AI-generated fields based on your contract type",
  "dynamicPrompt": "Based on the {{contractType}} and {{jurisdiction}}, generate relevant fields for additional terms.",
  "dynamicMaxFields": 5
}

### CONDITIONAL VISIBILITY (conditions)

Show/hide screens and fields dynamically based on user responses from earlier in the form.
This creates a more personalized, streamlined experience by only showing relevant questions.

**Condition Structure (for both screens and fields):**
{
  "conditions": {
    "operator": "and" | "or",
    "rules": [
      { "field": "fieldName", "operator": "equals", "value": "someValue" }
    ]
  }
}

**Available Operators:**
| Operator | Description | Example Value |
|----------|-------------|---------------|
| equals | Exact match | "full-time" |
| notEquals | Not equal to | "contractor" |
| contains | String/array contains | "tech" |
| notContains | Does not contain | "temp" |
| isEmpty | Field is empty/null | (no value needed) |
| isNotEmpty | Field has a value | (no value needed) |
| greaterThan | Numeric comparison | 50000 |
| lessThan | Numeric comparison | 100000 |
| greaterThanOrEqual | >= comparison | 30 |
| lessThanOrEqual | <= comparison | 65 |
| in | Value in array | ["CHF", "EUR", "USD"] |
| notIn | Value not in array | ["intern", "temp"] |
| startsWith | String starts with | "Senior" |
| endsWith | String ends with | "Manager" |

**Example - Conditional Field (show bonus only for full-time employees):**
{
  "name": "bonusPercentage",
  "label": "Annual Bonus Percentage",
  "type": "number",
  "required": false,
  "conditions": {
    "operator": "and",
    "rules": [
      { "field": "employmentType", "operator": "equals", "value": "full-time" }
    ]
  }
}

**Example - Conditional Screen (show IP assignment only if confidentiality enabled):**
{
  "title": "Intellectual Property Assignment",
  "type": "standard",
  "conditions": {
    "operator": "and",
    "rules": [
      { "field": "includeConfidentiality", "operator": "equals", "value": true }
    ]
  },
  "fields": [...]
}

**Example - Multiple Conditions with OR (show for senior roles OR high salary):**
{
  "name": "equityPackage",
  "label": "Equity/Stock Options",
  "type": "text",
  "conditions": {
    "operator": "or",
    "rules": [
      { "field": "seniorityLevel", "operator": "in", "value": ["director", "vp", "c-level"] },
      { "field": "annualSalary", "operator": "greaterThan", "value": 150000 }
    ]
  }
}

**Strategic Use Cases:**
- Show compensation details only for paid roles (not volunteer/internship)
- Show IP assignment section only when confidentiality is enabled
- Show probation period fields only for permanent contracts
- Show jurisdiction-specific clauses based on country/region selection
- Show equity/stock fields only for senior positions
- Show relocation benefits only if work location differs from employee location
- Show non-compete clauses only for certain industries or roles

**Best Practices:**
1. Reference fields from EARLIER screens only (conditions evaluate against already-collected data)
2. Use field names in camelCase exactly as defined
3. For checkboxes, compare against boolean true/false
4. Keep conditions simple - complex logic can confuse users
5. Consider combining with AI enrichment for smart defaults on conditional fields
`;

// Base system prompt - includes role, approach, and output format
const BASE_SYSTEM_PROMPT = `You are an expert AI assistant helping ADMINS build **reusable form templates**. These templates are multi-screen questionnaires that END USERS will fill out to generate legal contracts.

**Key distinction:**
- YOU are talking to an ADMIN who is building the template
- END USERS will later fill out the form to generate their contracts
- The template should be FLEXIBLE enough to serve many different end users

Your role: understand what flexibility/options the template needs, then propose a complete screen structure.

## CRITICAL: TEMPLATE DESIGN PHILOSOPHY

**Templates should be GENERALIZED, not specific:**
- Design for the COMMON CASE, not edge cases
- Create fields that work for ANY user of this template type
- Use generic labels like "Party A" not "John Smith's Company"
- Include helpful placeholders and helpText to guide any user

**ONLY be specific when user explicitly requests narrow use cases.**

## YOUR CONVERSATIONAL APPROACH - DISCOVERY FIRST, THEN FULL PROPOSAL

### PHASE 1: DISCOVERY (Ask questions, NO actions yet)

When user starts a new template or makes a request, have a conversation to understand the COMPLETE picture:

**Questions to explore (about TEMPLATE scope, not a specific contract):**
1. "What flexibility should end users have?" (e.g., contract variations, duration options, party configurations)
2. "What party types should the template support?" (company-to-company, company-to-individual, individual-to-individual, etc.)
3. "Should the template work internationally or focus on specific regions?"
4. "Any optional sections end users should be able to include/exclude?"
5. "Any industry-specific variations needed?" (tech, healthcare, finance, general, etc.)

**When the admin specifies a document type (e.g., "employment agreement", "NDA", "service contract"), do NOT ask what type of document they want—they already told you. Instead, ask about template FLEXIBILITY and what OPTIONS end users should have.**

**During discovery:**
- Ask 2-3 questions at a time, not all at once
- Use quick reply suggestions to make it easy for user to respond
- Build up your understanding of the complete template
- Keep actions array EMPTY - just ask questions

**IMPORTANT: You are NOT generating a contract for the admin. You are building a FORM TEMPLATE that many different end users will fill out to generate their own contracts. Your questions should focus on:**
- What OPTIONS should end users have? (dropdowns, checkboxes, variations)
- What FLEXIBILITY does the template need? (multiple party types, jurisdictions, industries)
- What SECTIONS are optional vs. required for end users?

**Do NOT ask the admin questions as if THEY are the one who needs a contract. They are building a template for OTHERS to use.**

### PHASE 2: SEQUENTIAL SCREEN CREATION (One screen at a time)

Once you have enough context (usually after 2-3 exchanges), start building the template ONE SCREEN AT A TIME:

**CRITICAL: Create screens sequentially, not all at once!**
- Each response should contain EXACTLY ONE createScreen action
- After the screen is auto-applied, immediately continue with the next screen
- Include a brief message about what you're creating and what comes next
- Continue until all screens are created (typically 4-8 screens)

**Your first creation response should:**
1. Briefly outline the full template plan (so user knows what's coming)
2. Include ONE createScreen action for the first screen
3. Mention "Creating screen 1 of X..." in the message

**Example creation message:**
"I'll build your Employment Agreement template with 6 screens. Let me create them one by one so you can see the template take shape.

**Creating screen 1 of 6: Employer Information**
This screen collects company details and uses AI enrichment to detect jurisdiction for smart defaults later."

**IMPORTANT: After each screen creation, your next response should automatically create the next screen without waiting for user input. The system will auto-apply each screen.**

### PHASE 3: REFINEMENT (After creation)

After user applies the screens, offer to:
- Add more fields to specific screens
- Adjust AI enrichment configurations
- Add additional screens if needed
- Fine-tune field options or help text

${FORM_SCHEMA_REFERENCE}

## OUTPUT FORMAT

**CRITICAL: Your ENTIRE response must be ONLY valid JSON. Start with { and end with }. No text before or after.**

{
  "message": "Your conversational response - questions during discovery OR screen creation progress",
  "suggestions": ["Quick reply 1", "Quick reply 2"],
  "actions": [],
  "autoNext": false
}

**Field explanations:**
- "autoNext": true signals the system to auto-apply the action and continue to next screen without user input
- During creation phase, set autoNext: true and include exactly ONE createScreen action
- During final screen creation, set autoNext: false so user can review the complete template

**During Discovery Phase:**
- actions: [] (empty - just asking questions)
- suggestions: Answer options for your questions

**During Creation Phase:**
- actions: [ONE createScreen action only] (screens are created sequentially)
- suggestions: [] (empty - system auto-continues to next screen)
- Set "autoNext": true in the response to signal the system to auto-continue

## ACTION TYPES

1. **"createScreen"**: Creates a new screen at the end of the template
   - For standard: Include fields array with aiSuggestionEnabled where appropriate
   - For signatory: Include signatoryConfig with party types
   - For dynamic: Include dynamicPrompt and dynamicMaxFields
   - Include aiEnrichment on information-gathering screens

2. **"updateScreen"**: Modifies an existing screen (IMPORTANT for editing existing templates!)
   - **MUST include "screenId"**: The ID of the screen to update (from template context)
   - Include ALL properties to update: title, description, fields, enableApplyStandards, aiEnrichment, etc.
   - For fields: provide the COMPLETE updated fields array (replaces existing fields)
   - Use when: adding AI features to existing screens, enabling Apply Standards, modifying fields

3. **"addFields"**: Adds fields to currently selected screen
   - Use during refinement phase
   - Only when user wants to add more fields to existing screen

4. **"removeScreen"**: Deletes a screen from the template
   - **MUST include "screenId"**: The ID of the screen to remove
   - Use when user wants to remove unnecessary screens

5. **"reorderScreens"**: Changes the order of screens
   - **MUST include "screenOrder"**: Array of screen IDs in new order
   - Use when optimizing screen flow (e.g., moving enrichment screens earlier)

## WHEN EDITING EXISTING TEMPLATES

**CRITICAL**: When the template already has screens, you're in EDIT MODE:

1. **Analyze existing screens first** - look at what's already there
2. **Use updateScreen to improve** - don't recreate screens, update them!
3. **Preserve screen IDs** - always reference existing screenId
4. **Be specific about changes** - explain what you're adding/modifying

**Example: Adding Apply Standards to existing screen:**
{
  "type": "updateScreen",
  "data": {
    "screenId": "existing-screen-uuid",
    "enableApplyStandards": true,
    "fields": [
      // ... complete updated fields array with aiSuggestionEnabled added
    ]
  }
}

## STRATEGIC FLOW DESIGN FOR FRICTIONLESS UX

**PRIORITY: Minimize user effort while maintaining legal quality**

Design templates to maximize AI-assisted form filling and conditional logic:

### OPTIMAL SCREEN FLOW PATTERN:

**Screen 1: Essential Input + Enrichment**
- Collect MINIMAL essential info (company name, address, role, etc.)
- Add aiEnrichment to infer: jurisdiction, industry, currency, market standards
- User must fill this manually (it's the seed data for AI)

**Screen 2: Secondary Info (Buffer Screen)**
- Collect additional required info that user must provide
- AI enrichment runs in background while user fills this
- Can also add enrichment here for more context

**Screen 3+: AI-Assisted Screens (enableApplyStandards: true)**
- Enable "Apply Standards" button
- Most/all fields have aiSuggestionEnabled + aiSuggestionKey
- User clicks ONE button to fill multiple fields at once
- They can review and adjust if needed

**Last Screen: Signatories**
- Collect signing parties
- Standard signatory screen configuration

### EXAMPLE EMPLOYMENT AGREEMENT FLOW:

1. **Employer Info** (aiEnrichment → jurisdiction, industry, companySize, currency, salaryRange)
2. **Employee Info** (user fills while enrichment runs)
3. **Position Details** (enableApplyStandards: true, fields use enrichment)
4. **Compensation** (enableApplyStandards: true, salary/benefits from enrichment)
5. **Working Conditions** (enableApplyStandards: true)
6. **Confidentiality** (standard clauses, minimal AI needed)
7. **Signatories** (employer + employee)

### ENRICHMENT OUTPUT RECOMMENDATIONS:

From company/party info, generate:
- jurisdiction, tradingCurrency, industrySector
- companySize, companyType, operatingRegions

From role/position info, generate:
- employmentType, seniorityLevel, departmentType
- marketSalaryRange, standardBenefits, typicalProbationPeriod

## IMPORTANT RULES

1. **PURE JSON response** - no text before/after, no markdown code blocks
2. **ALL conversation in "message"** field
3. **EDITING EXISTING TEMPLATES** - If screens already exist, use "updateScreen" action type with the screen's screenId. NEVER use "createScreen" for screens that already exist!
4. **ALWAYS OUTPUT ACTIONS** - When the user asks to "apply", "make changes", "update", or similar, you MUST include actions in your response. Don't just describe changes - include the actual updateScreen/createScreen actions!
5. **DISCOVERY FIRST** - For new templates, ask questions before creating to understand the FULL template needs
6. **ONE SCREEN AT A TIME** - Create screens sequentially, one per response. Include "autoNext": true to signal auto-continuation
7. **MAXIMIZE APPLY STANDARDS** - enable on screens 3+ where enrichment data is available
8. **FRICTIONLESS FLOW** - early screens collect data, later screens auto-fill
9. **GENERALIZED design** - templates serve many users, not specific individuals
10. **camelCase field names** - unique within screen
11. **Select fields require "options"** array
12. **AI enrichment on screens 1-2** - generate context for smart defaults later
13. **Fields with aiSuggestionKey** - enable aiSuggestionEnabled: true
14. **Signatory screen last** - always end with signature collection
15. **USE CONDITIONS for dynamic forms** - add conditions to screens/fields to show/hide based on earlier responses
16. **CONDITIONS reference earlier fields** - only reference fields from screens that appear BEFORE the conditional element`;

// Default business logic prompt (minimal fallback - full prompt is in admin settings)
const DEFAULT_BUSINESS_LOGIC_PROMPT = `Build reusable, frictionless legal form templates. Use AI enrichment on early screens, enable Apply Standards on screens 3+, add conditional visibility for party-type branching (individual vs organization), and place signatories last. Keep screens to 3-6 fields with plain-English labels.`;

// Condition rule schema for conditional visibility
const conditionRuleSchema = z.object({
  field: z.string(),
  operator: z.string(),
  value: z.unknown().optional(),
});

const conditionGroupSchema = z.object({
  operator: z.enum(["and", "or"]),
  rules: z.array(conditionRuleSchema),
});

// Request validation schema
const requestSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(["user", "assistant"]),
      content: z.string(),
    })
  ),
  templateContext: z.object({
    templateId: z.string(),
    templateTitle: z.string(),
    templateDescription: z.string().optional(),
    screens: z.array(
      z.object({
        id: z.string(),
        title: z.string(),
        description: z.string().nullable().optional(),
        order: z.number(),
        type: z.enum(["standard", "signatory", "dynamic"]).optional().default("standard"),
        enableApplyStandards: z.boolean().optional().default(false),
        aiPrompt: z.string().nullable().optional(),
        aiOutputSchema: z.string().nullable().optional(),
        signatoryConfig: z.string().nullable().optional(), // JSON string
        dynamicPrompt: z.string().nullable().optional(),
        dynamicMaxFields: z.number().nullable().optional(),
        conditions: z.string().nullable().optional(), // JSON string for screen conditions
        fields: z.array(
          z.object({
            name: z.string(),
            label: z.string(),
            type: z.string(),
            required: z.boolean(),
            placeholder: z.string().nullable().optional(),
            helpText: z.string().nullable().optional(),
            options: z.array(z.string()).optional(),
            aiSuggestionEnabled: z.boolean().optional(),
            aiSuggestionKey: z.string().nullable().optional(),
            conditions: z.string().nullable().optional(), // JSON string for field conditions
          })
        ),
      })
    ),
  }),
  selectedScreenId: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validation = requestSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: "Validation failed", details: validation.error.format() },
        { status: 400 }
      );
    }

    const { messages, templateContext, selectedScreenId } = validation.data;

    // Get session ID for analytics
    const sessionId = await getSessionId();

    // Fetch AI model from settings
    const aiModelSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorAiModel" },
    });
    const aiModel = aiModelSetting?.value || DEFAULT_CONFIGURATOR_MODEL;

    // Fetch business logic prompt from settings
    const businessLogicSetting = await prisma.systemSettings.findUnique({
      where: { key: "templateConfiguratorBusinessLogic" },
    });
    const businessLogicPrompt =
      businessLogicSetting?.value || DEFAULT_BUSINESS_LOGIC_PROMPT;

    // Find selected screen if specified
    const selectedScreen = selectedScreenId
      ? templateContext.screens.find((s) => s.id === selectedScreenId)
      : null;

    // Build the full system prompt
    const systemPrompt = `${BASE_SYSTEM_PROMPT}

## CURRENT TEMPLATE CONTEXT

Template: ${templateContext.templateTitle}
${templateContext.templateDescription ? `Description: ${templateContext.templateDescription}` : ""}

## EXISTING SCREENS (${templateContext.screens.length} total)

${
  templateContext.screens.length === 0
    ? "No screens have been created yet. Use 'createScreen' actions to build the template."
    : `**YOU ARE IN EDIT MODE** - Use 'updateScreen' with screenId to modify existing screens!

${templateContext.screens
        .map(
          (screen, idx) => {
            // Type info
            const screenType = (screen as { type?: string }).type || 'standard';
            const hasApplyStandards = (screen as { enableApplyStandards?: boolean }).enableApplyStandards;
            const screenConditions = (screen as { conditions?: string }).conditions;
            
            let screenInfo = `
### Screen ${idx + 1}: ${screen.title}
**screenId: "${screen.id}"** ← Use this ID for updateScreen/removeScreen actions
Type: ${screenType}${hasApplyStandards ? ' | ✓ Apply Standards ENABLED' : ' | ✗ Apply Standards NOT enabled'}`;
            
            // Add screen conditions info if present
            if (screenConditions) {
              try {
                const cond = JSON.parse(screenConditions);
                if (cond.rules && cond.rules.length > 0) {
                  const condDesc = cond.rules.map((r: any) => `${r.field} ${r.operator} ${r.value ?? ''}`).join(` ${cond.operator.toUpperCase()} `);
                  screenInfo += `\n**Conditional**: Shows when ${condDesc}`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            
            screenInfo += `
${screen.description ? `Description: ${screen.description}` : ""}
Fields (${screen.fields.length}):
${
  screen.fields.length === 0
    ? "  - No fields yet"
    : screen.fields
        .map(
          (f) => {
            const hasSuggestion = (f as { aiSuggestionEnabled?: boolean }).aiSuggestionEnabled;
            const suggestionKey = (f as { aiSuggestionKey?: string }).aiSuggestionKey;
            const fieldConditions = (f as { conditions?: string }).conditions;
            let fieldInfo = `  - ${f.name} (${f.type}${f.required ? ", required" : ""}): "${f.label}"${hasSuggestion ? ` [AI suggestion: ${suggestionKey}]` : ''}`;
            
            // Add field conditions info if present
            if (fieldConditions) {
              try {
                const cond = JSON.parse(fieldConditions);
                if (cond.rules && cond.rules.length > 0) {
                  const condDesc = cond.rules.map((r: any) => `${r.field} ${r.operator} ${r.value ?? ''}`).join(` ${cond.operator} `);
                  fieldInfo += ` [CONDITIONAL: ${condDesc}]`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            return fieldInfo;
          }
        )
        .join("\n")
}`;
            // Add enrichment info if present
            if (screen.aiOutputSchema) {
              try {
                const schema = JSON.parse(screen.aiOutputSchema);
                if (schema.properties) {
                  const outputVars = Object.keys(schema.properties);
                  screenInfo += `\nAI Enrichment outputs: ${outputVars.join(", ")}`;
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
            return screenInfo;
          }
        )
        .join("\n")}`
}

## AVAILABLE ENRICHMENT VARIABLES FOR aiSuggestionKey

${(() => {
  const availableVars: string[] = [];
  templateContext.screens.forEach((screen) => {
    if (screen.aiOutputSchema) {
      try {
        const schema = JSON.parse(screen.aiOutputSchema);
        if (schema.properties) {
          Object.keys(schema.properties).forEach((key) => {
            availableVars.push(key);
          });
        }
      } catch (e) {
        // Ignore parse errors
      }
    }
  });
  return availableVars.length > 0
    ? `These variables are available from previous screen enrichments: ${availableVars.join(", ")}\nUse these as aiSuggestionKey values for fields in new screens.`
    : "No enrichment variables available yet. Consider adding AI enrichment to early screens to generate context variables.";
})()}

${
  selectedScreen
    ? `
## CURRENTLY SELECTED SCREEN

The user has selected "${selectedScreen.title}" - if they ask to add fields, add them to this screen using the "addFields" action type.
`
    : `
## NO SCREEN SELECTED

If the user asks to add fields to an existing screen, remind them to select a screen first, or suggest creating a new screen.
`
}

## ADMIN BUSINESS LOGIC INSTRUCTIONS

${businessLogicPrompt}`;

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] System prompt length:", systemPrompt.length);
      console.log("[TEMPLATE_CONFIGURATOR] Messages count:", messages.length);
      console.log("[TEMPLATE_CONFIGURATOR] Using model:", aiModel);
    }

    // Build conversation messages
    const conversationMessages = [
      { role: "system" as const, content: systemPrompt },
      ...messages.map((m) => ({
        role: m.role as "user" | "assistant",
        content: m.content,
      })),
    ];

    // Call OpenRouter
    const completion = await createCompletionWithTracking(
      {
        model: aiModel,
        messages: conversationMessages,
        response_format: { type: "json_object" },
        temperature: 0.7,
        max_tokens: 32768, // Doubled for comprehensive multi-screen templates
      },
      {
        sessionId,
        endpoint: "/api/ai/template-configurator",
      }
    );

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error("No content received from AI");
    }

    if (process.env.NODE_ENV === "development") {
      console.log("[TEMPLATE_CONFIGURATOR] Raw response length:", content.length);
      console.log("[TEMPLATE_CONFIGURATOR] Response starts with:", content.substring(0, 100));
      console.log("[TEMPLATE_CONFIGURATOR] Response ends with:", content.substring(content.length - 100));
    }

    // Parse and validate the response
    let response;
    try {
      // First try direct JSON parsing
      response = JSON.parse(content);
    } catch (parseError) {
      if (process.env.NODE_ENV === "development") {
        console.log("[TEMPLATE_CONFIGURATOR] Direct parse failed:", parseError);
        // Log the error position if available
        if (parseError instanceof SyntaxError) {
          const match = parseError.message.match(/position (\d+)/);
          if (match) {
            const pos = parseInt(match[1]);
            console.log("[TEMPLATE_CONFIGURATOR] Error at position:", pos);
            console.log("[TEMPLATE_CONFIGURATOR] Context around error (pos-100 to pos+100):");
            console.log(content.substring(Math.max(0, pos - 100), Math.min(content.length, pos + 100)));
            console.log("[TEMPLATE_CONFIGURATOR] Character at position:", JSON.stringify(content[pos]));
          }
        }
      }
      
      // Check if the response contains any JSON object at all
      const firstBrace = content.indexOf('{');
      const lastBrace = content.lastIndexOf('}');
      
      // If no JSON object found, the AI returned plain text - wrap it in a response
      if (firstBrace === -1 || lastBrace <= firstBrace) {
        if (process.env.NODE_ENV === "development") {
          console.log("[TEMPLATE_CONFIGURATOR] AI returned plain text (no JSON), wrapping as message");
        }
        response = {
          message: content.trim(),
          suggestions: ["Continue", "Try again", "Start over"],
          actions: []
        };
      } else {
        // Try to extract JSON object from content (AI sometimes outputs text before/after JSON)
        let jsonContent = content.substring(firstBrace, lastBrace + 1);
        if (process.env.NODE_ENV === "development" && firstBrace > 0) {
          console.log("[TEMPLATE_CONFIGURATOR] Extracted JSON from position", firstBrace, "to", lastBrace);
          console.log("[TEMPLATE_CONFIGURATOR] Text before JSON:", content.substring(0, Math.min(firstBrace, 100)));
        }
        
        // Try to repair JSON using jsonrepair library
        try {
          const repaired = jsonrepair(jsonContent);
          const parsed = JSON.parse(repaired);
          
          // Ensure we got an object with message, not just a string
          if (typeof parsed === 'object' && parsed !== null && 'message' in parsed) {
            response = parsed;
            if (process.env.NODE_ENV === "development") {
              console.log("[TEMPLATE_CONFIGURATOR] Fixed JSON with jsonrepair");
            }
          } else {
            // jsonrepair returned something unexpected, use original content as message
            if (process.env.NODE_ENV === "development") {
              console.log("[TEMPLATE_CONFIGURATOR] jsonrepair returned non-object, using content as message");
            }
            response = {
              message: content.trim(),
              suggestions: ["Continue", "Try again"],
              actions: []
            };
          }
        } catch (repairError) {
          if (process.env.NODE_ENV === "development") {
            console.log("[TEMPLATE_CONFIGURATOR] jsonrepair failed:", repairError);
          }
          
          // Try to extract JSON from markdown code blocks as fallback
          const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
          if (jsonMatch && jsonMatch[1]) {
            try {
              const repairedBlock = jsonrepair(jsonMatch[1].trim());
              const parsed = JSON.parse(repairedBlock);
              if (typeof parsed === 'object' && parsed !== null && 'message' in parsed) {
                response = parsed;
                if (process.env.NODE_ENV === "development") {
                  console.log("[TEMPLATE_CONFIGURATOR] Extracted and repaired JSON from markdown code block");
                }
              }
            } catch (innerParseError) {
              // Continue to fallback
            }
          }
        }
      }
      
      // Final fallback: create a response explaining the issue
      if (!response) {
        console.error("[TEMPLATE_CONFIGURATOR] All parse methods failed. Content length:", content.length);
        console.error("[TEMPLATE_CONFIGURATOR] Last 200 chars:", content.substring(content.length - 200));
        
        // Check if this looks like truncated JSON (has opening { but response is long)
        const isTruncated = content.startsWith('{') && content.length > 5000 && !content.trim().endsWith('}');
        
        if (isTruncated) {
          response = {
            message: "My response was too long and got cut off. Let me create a simpler version with fewer screens. Would you like me to try again with a more compact template, or should I create the screens one at a time?",
            suggestions: ["Create compact version", "Create screens one at a time", "Try again"],
            actions: []
          };
        } else {
          response = {
            message: "I had trouble formatting my response. Could you please try again?",
            suggestions: ["Try again", "Start over", "Create a simple template"],
            actions: []
          };
        }
      }
    }

    // Ensure response has required structure
    if (!response.message) {
      response.message = "I've processed your request.";
    }
    if (!response.actions) {
      response.actions = [];
    }

    // Validate actions structure
    const originalActionsCount = response.actions?.length || 0;
    response.actions = (response.actions || []).filter((action: any) => {
      if (!action.type || !action.data) {
        if (process.env.NODE_ENV === "development") {
          console.log("[TEMPLATE_CONFIGURATOR] Filtered out action - missing type or data:", action?.type);
        }
        return false;
      }
      
      if (action.type === "createScreen") {
        // Must have a title
        if (!action.data.title) return false;
        
        const screenType = action.data.type || "standard";
        
        // Validate based on screen type
        if (screenType === "standard") {
          // Standard screens should have fields array (can be empty)
          return Array.isArray(action.data.fields);
        } else if (screenType === "signatory") {
          // Signatory screens need signatoryConfig
          return action.data.signatoryConfig !== undefined;
        } else if (screenType === "dynamic") {
          // Dynamic screens need dynamicPrompt
          return action.data.dynamicPrompt !== undefined;
        }
        
        // Default: accept if has title
        return true;
      }
      
      if (action.type === "updateScreen") {
        // Must have screenId to know which screen to update
        if (!action.data.screenId) {
          if (process.env.NODE_ENV === "development") {
            console.log("[TEMPLATE_CONFIGURATOR] updateScreen rejected - missing screenId");
          }
          return false;
        }
        // Accept if has screenId - can update any properties
        return true;
      }
      
      if (action.type === "addFields") {
        return Array.isArray(action.data);
      }
      
      if (action.type === "removeScreen") {
        // Must have screenId to know which screen to remove
        return !!action.data.screenId;
      }
      
      if (action.type === "reorderScreens") {
        // Must have screenOrder array
        return Array.isArray(action.data.screenOrder) && action.data.screenOrder.length > 0;
      }
      
      return false;
    });

    if (process.env.NODE_ENV === "development") {
      const actionTypes = response.actions.map((a: any) => a.type);
      console.log("[TEMPLATE_CONFIGURATOR] Response:", {
        message: response.message.substring(0, 100) + "...",
        originalActionsCount,
        validActionsCount: response.actions.length,
        actionTypes: actionTypes.length > 0 ? actionTypes : "none",
        filteredOut: originalActionsCount - response.actions.length,
      });
    }

    return NextResponse.json(response);
  } catch (error) {
    console.error("[TEMPLATE_CONFIGURATOR]", error);
    return NextResponse.json(
      {
        error: "Failed to process request",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
